{"title":"Gen Overview","description":"Overview of Gen, the graph-based programming language for low-level signal processing.","headings":[{"depth":1,"id":"gen","text":"Gen"},{"depth":2,"id":"why-use-gen","text":"Why Use Gen?"},{"depth":3,"id":"examples","text":"Examples"},{"depth":3,"id":"performance-improvements","text":"Performance Improvements"},{"depth":2,"id":"working-with-gen","text":"Working with Gen"},{"depth":2,"id":"creating-a-gen-patch","text":"Creating a Gen Patch"},{"depth":2,"id":"patching-in-gen","text":"Patching in Gen"},{"depth":3,"id":"conceptual-differences-between-max-and-gen","text":"Conceptual differences between Max and Gen"},{"depth":2,"id":"autocompile","text":"Auto-compile"},{"depth":2,"id":"gen-operators","text":"Gen Operators"},{"depth":2,"id":"standard-operators","text":"Standard Operators"},{"depth":2,"id":"argument-expressions","text":"Argument Expressions"},{"depth":2,"id":"send-and-receive","text":"Send and Receive"},{"depth":2,"id":"subpatchers-and-abstractions","text":"Subpatchers and Abstractions"},{"depth":2,"id":"subpatcherabstractions-and-parameters","text":"Subpatcher/Abstractions and Parameters"},{"depth":2,"id":"setting-parameter-defaults","text":"Setting Parameter Defaults"},{"depth":2,"id":"the-gen~-object","text":"The gen~ Object"},{"depth":2,"id":"gen~-operators","text":"gen~ Operators"},{"depth":2,"id":"history","text":"History"},{"depth":2,"id":"delay","text":"Delay"},{"depth":2,"id":"data-and-buffer","text":"Data and Buffer"},{"depth":2,"id":"eventrate-gen","text":"Event-rate Gen"},{"depth":2,"id":"technical-notes","text":"Technical notes"},{"depth":2,"id":"jitter-gen-objects","text":"Jitter Gen Objects"},{"depth":2,"id":"jitter-operators","text":"Jitter Operators"},{"depth":3,"id":"coordinates","text":"Coordinates"},{"depth":3,"id":"vectors","text":"Vectors"},{"depth":3,"id":"sampling","text":"Sampling"},{"depth":3,"id":"geometry","text":"Geometry"},{"depth":3,"id":"color","text":"Color"},{"depth":2,"id":"jit_gen","text":"jit.gen"},{"depth":2,"id":"jit_pix","text":"jit.pix"},{"depth":2,"id":"jit_gl_pix","text":"jit.gl.pix"},{"depth":2,"id":"technical-notes-jitter-gen","text":"Technical notes (Jitter Gen)"},{"depth":3,"id":"numerical-values-in-the-kernel","text":"Numerical Values in the Kernel"},{"depth":3,"id":"jit_pix-vs_-jit_gl_pix","text":"jit.pix vs. jit.gl.pix"},{"depth":2,"id":"see-also","text":"See Also"}],"patchers":[{"id":"patch-07a24b3a-24a5-4cdf-b4ff-1e70769c7f17","content":"----------begin_max5_patcher----------\n527.3ocwW11aaBCDG+0vmBK+xozHr4g.8qRU0jC305tfAgMYIppe2m4LrlUk\nAtpNr2PjOeg+2Oe9NadML.uu4DWgQ2id.ED7ZXP.XZvPv33.bM6T4AlBbCK4\n+pY+K3M1oz7SZv7yBkto6L5LcZpVlt7Yg7ou2wK0VEhyoai1fHI4C+jEM7jZ\nLgdb7+H6qExCbMHE4ciM85OZUTA5Zhk6hylzz5m9bK2JHFidbXl2BCGdr4qw\nXKqiUi1SQQamixjznKnbWw7TF4LkoqJkjEnjlStITlrNT9MG1lluCfpXa5bn\nQcFs3++nQSuMnQWGz9SWFxxLVP7aSFx5fnhKqP+fyq1yJ+4rTBEdwT.1w74m\nDynqfYD1erXhVt3H2Mb.NRSfTmu5lPKVmjl4silaKIYW5EIq3TOkrn4dLYc2\nxwOMi301FzcqS5QHcI6XKnn49Zumq2JAzAePH+3EwfPcv9eSrpouqb5UMsLh\ndObq3JsPxzhF4ENYJruzoltJdGvyUWlcU5gF+KJMDej+QB0YkhWMkRcY4L1G\nJk3hRTenDwUktxVDxWS5LWWNiVEHytE0ACGzrrzDO.oSE6lCFtAYRZlqkfQW\noAGqs8HuSM5MHho48KMPfUrAFJj1gPSVy0GNJl72Zg0Y5cqMMt66f.CeJy98\nB35FChxdwHkF7LRBGLHY0bUKyRBtR0t8ItDG9V3uA3oHjkH\n-----------end_max5_patcher-----------"},{"id":"patch-1bd4c24f-d3a9-4a03-860a-f6ec3143bb9a","content":"----------begin_max5_patcher----------\n993.3ocyXE0ihCBD945uhFd7N0TpVc8d69crYiAaQk8pPOf5p2l6+9QAZkVa\nqcytt2FSz3L.y78wvLv75HOvF1Ir.3+C+G887dcjmmVTg.O6+8.GPmhSQB8v\n.T7KrMOCFaTIwmjZweyOrTVFRFumP2sliiklkdUzzfw9vnUE+DNS+c3z.+mr\nSglefPSwRsIfWDxxkMkRRz1S4CSVTZQyvjmyvFyA.9OUn4uiFU7032Gz1go9\nGNOQRTFoGLNWCKXPPwOKg8iwvVwX30XLpaLNViSWGBysnyBOOvVRJ9HlKHLp\nCI5APYYNh8blRAm7LSuPqFWIhPMhBpDwwGIky+hTDWQKREmjy09I3zh4fKKC\nKAyo4DsqXDp1crtjdefhNfEYnXyjSDYSUre4B.tP1gOrvPvZddVvb8+JByJY\nD0l8tTV7uvItdHfkgoDZFGKvTIR1..fD7VTdpb8VFUJH+Q6FP0tXa52ZcyVU\nV.DMF9ImfRqPvNNIgQKbhZaGEhKM2ipyIlSKtfQOBJJqkIqBST7RGJEJPlK1\nf3E6VaRwNgYpPbFKstpp4kh2JspyHTZCVTxx5VImraeOycCSo7PeqsViXcN0\nncsJvPtVfNVmsknzT6I15K+IDkb.IwRhYKHLnRIlhT.cuHlyRSqgWilisnIQ\nEnGiegjH2qMjavfZ3jrxfHP0tbBYGVHqKSh1IpKQHOaHcGQ4arGjWKwGxRUn\nn9.TGQHBoXO6EgcfkAZAWNGkiU7WSR4RVd2C6toDqIuuTi0SOpRLUk6uqbiv\nEK0gzqzmSmE0L4XmEAZIIYfiFmDkKAkh0Y8s4V93g6jAB0PSBpUSitETC6Dp\nv1g5BWWnqZe2el362fIhBt2DQzWChfP8gChKlYJS8vsC+CdqTA7KCUbybAKW\ndm4hvuFbQQhwgEWbOyKNus7hWtWQJg1UkAs6VnucZPvx4wkjp8znecOWUfTR\nnU2x5wROROtAsI7V8gECzGVdG8gvA5CE9Jr13X7DyU3CtKNF7M3XAelN1PYr\nntYL3+UFKpaFC16wOl5xxDp83px6l.mGtr51dLQr5YJIEOap9iXLxySxPIIZ\nq.fgprppOPv0CJiw0oalELa1RG0pzPXxQbaKuUUiI+fyH9cNle1bq4lSV85p\nsjSssrFMlqzN5Bo7w7Ncmxvc+9baAmG5+44ACsEDvOmVP3TVs61q7ACsvOGn\n4VkrmssvUsWgbHsNJ3ZvYpJZQfdspWIz.nloKrvp+pN2tp2UD2PsSs7e8m79\ncamOC7DN.6Xw76xNvAZm53wDVznSYElnQGxZzcrq6LV2cEqYGwzcCquNgM5u\ni92BIlpn\n-----------end_max5_patcher-----------"},{"id":"patch-c3e1bb92-0bea-4416-97e1-d0876e37615f","content":"----------begin_max5_patcher----------\n487.3ocuU0taaCBE821OEH94jWZv1wez1s2f8DLMMQrosDk.V.tMaU8cevE6\nUmszXTkU4GXwwW3bOv4BOGGg2JOxzXz0nuihhdNNJBfb.QCiivGnGa1S0PXX\nA6I41c3D+uLriF.V1aPjQzNpo4At39epXMF+hSJSWsNAQpItOYab8oVHzOFl\nin+.WrmY.VHuBZW3Qz0Cn7VOka28YBA6vdIN10kDnFZjsLWDyltUoqxl1xyr\n4dNj7EjII+cRgQPOvfU+1uIERcGsg09U7kTmaV2YCap1NUwjyn30iqoONyu5\nX9bFiOIez7eC+f3ThG1o6wSKB5KHtff9Dx7jriitBooG51yTTC6l2yl5aXL3\nhP7Eo4Pe0ksEAuIUeo8nkSayY5yp+qmeZKsZAq.pVvypodf4kUVwphosphDT\n46RVm4Dr7i4Dbv8OqXO2EA4KkVK9Xz5LUhdgNTBtTEhaBTZ.M38bw+9XDjnN\n7S0qV1qZFWpwqEQulssLsgKnFtTLMHhOnytmFJS0gPz5Efnx.HpZA3oH.dJW\n.d1D.OE+GOdmAsq6QlRODLPg0yuSpbCqSfgbgeHXNwJ1i7w38HTk0xar98dk\n+UviE4X+TsuKpD8bvDG6DmkRndx8nN7TNLgVc2p6YBb7Kw+AmnFGqC\n-----------end_max5_patcher-----------"},{"id":"patch-4a056bd7-3012-466b-bc3c-e59205bb42ac","content":"----------begin_max5_patcher----------\n602.3ocyU0zbaCBD8rzuBFtzCwUQnuUSaOmK8WPSlNJRjXxXAZ.jqSyj+6EV\njrc9n1Zh0jobPZX4w91GKr6i9d3aDanJL5Kneh77dz2yCLYM3ML2C2VsodUk\nBfg4zeKt4d7B2RZ5FMX9rQKcU55kL9c+RRq0NGGWFDt.QBys+hJCRMeiBBQW\nOrEdeKiuhpABh1YTzqGsRFrxZ.1LQvmiFYzAS+PG0QGFit1txS991OKNMgsj\nozB4CHUe6wkXRh8WdHHz+oDISUhjOFIZ7Nhb.wQxibBBTWb56Qcgug5H32gF\npEMTKhiFtYYPz5RIDaTuMduUv07pV3vD+0eH3BUWUMs463CIH6tt0.ae4b7T\nX3gxg64YE6OvBDav6LakJ3nyOG0PMGARJ5xgqiFeaD7Uxq3Wt6B5E14Fv8JJ\nRubK3OoPhUMn0Uq5oVDlHgf919aPQ0uXClqJ61fAoCO5LD4B77cyiwmzEOHE\nFUb36cSNkT9+wqJWIC3Q09inhY7IVwGWtZPNEyZpJchoJfF7JF+k8xf.0Z+4\n5UI5k0itZnRKZWv1PUZFuRyD78vXZ3fHawzxZ5DLtdfvjBaaMRQdPZbddVXB\nIyNJxb0dhyIgkw4SCRIIfjlmlFEVDaGIwKPovw6qWYa7HjMTIb39lo747fn3\nYX1RL4jHNZBDODbmDOoSLSep7TNE8DNCDM5jCyzqO5buYp55VSkpAz.IlpA2\nKfLZ4BXJi6lBOawR5Z1HdmkJooXf1TInW55WsIKA61poClj2yFtdXjmgRnRi\ns8KzzE1PipK3NJG6+j+eAvg00kE\n-----------end_max5_patcher-----------"},{"id":"patch-8a366637-c697-4d61-887f-cdb9f814fabd","content":"----------begin_max5_patcher----------\n495.3ocuVssTCBCD8Y3qHSdR6T6PJEn3s+.+BbbbnPZMcZSXBgZUG+2MYCXa\n0JlQQenIMK6lyd1bVBu36gmI1RqvnyQ2h77dw2yCLYL30r1CuNaa9prJvMLm\n9nX1R7P6iTzsJvrnVgF2ZsLSk+.iu3dIMWY2bRZvnfgHR7XyTXjYbr9+n6Zh\ngWulwWQU.JjcF0abq0fFqrBKjyVdFgfM1d022LLzQNjKJnFO91zMIDxyDhYJ\nNbuzctfq3Yqov9c4MBtnpLKmVbMtK9XhZt1s8YygbjbDNFztmV+TOURsYIFe\nP9TwdFd.wTislMLs87gftBsgleBiSzbZ.LELhb5E+jR3WHCXbWTAiSfwocKB\nbt.k1U8o+31fNoVR7nn2ELg+D48QX1z+GlYZdIcvsvz+hd2jdT2o00Zsbj9W\nhYvAxD.puzIcSlPWOoh+eNoz8WeO2541qHGoF.CdEi+wKTfD0X+P9VIpk4sa\nU6K5P6x1BZkhwyTLAeemHVmNZM0UjRcAnfd.noN.jV5fH+Rbhb.mCyEgrfJA\ncvuB3XG.NoGJjQNVHOBAIeRilUVtgJqZhFvT28sT.tmNDVx31kPaBVR2vZ82\nZISpa9T5NuZo8F1swSv1P024J40rFr0rUCIzYa9fA3yDf.VxTiVP4X+W8eC5\nAkxm\n-----------end_max5_patcher-----------"},{"id":"patch-6bcc27e4-14b9-485d-857e-756fe0b183b8","content":"----------begin_max5_patcher----------\n479.3ocuU0sSCBCE9Z3onoWOW3.aCwn9F3SfwXXP2rKasjRQmZ16tsmBtMmA\nHNb2Tne8z9c9N+z9ouGctbKqjRtg7Hwy6SeOODxB3UO2itIca15zRzLpf8lb\n9J5H2RZ1VMBKqzjvFzhTc1KbwxmUrLs6vg.XbvHBLKz9IZpcLz7O4o58Hp1v\nEqYZjEXOn4faPCpQ44NJmu5pHpEZmuucXz4Igx23ePBHP2p35D63zv+hHfSE\nw2wMmY52KXN5nTxSCr9TKaQdQI6U2jYCj5fKi5rEfQsk5RB9OJ.A3uTAlIyY\nVK5zciiP+LFK6lEcf6tPJzhzMXrjd6CRgrrHMikeOsM8X20BiYGpltyfAskB\nO3jK4efK.1XrC1pzl7CPtivEvXSM3vk24h1u2wEGCiwwqaOq26HRxkqlF5re\ncnKoiG1rS2BXfSNS6YxAogtlK94CfniZwOVukxJUVyQ0zWP16s4rRMWjp4Rw\ngFANi90XZeYJrGDEM.7LsG7bruHU4LEldNKhgdPb7ERfvuKP3rHNoODGbhBc\n0noEEuxTk0VibX59VIQ+JYDNkKbSw1Dph8JuwdGRpxz7oMcdUJ2ExamMg51p\n4JZknhWKRi5LThc112WvWUvMrhqGujIn967+Bz7VR8F\n-----------end_max5_patcher-----------"},{"id":"patch-491c516f-9461-4127-879b-3ee1a027b2fb","content":"----------begin_max5_patcher----------\n446.3ocuTFsaiCBDE8Y6uhQ73pzJC1tIs+JUQqHNi5RjMXgwIY2p9uW7fsZ6\nlpDTiUdADWO36bfY30zD1FyQriAOAOCIIulljPRCBIiqSXMxiU0xNJLVkooA\n0N1hv2b3QGoePUWCaPvGYSKtEbF34tCp+A70Sw1JcU+Qoe42VrxE7jyWde1B\nfuJLUlMLI7iv5wMo6aT5ZzQty+Pzz6lTyFUUaoLwrY2cqXCRuklNLr3JQqxh\nRGBRPbWasTivde9arQfU9CyKVK+IXowC98dBUdm.9YXnrfR57GGlxKoEhqlf\nxYj.p7J+hHvWQ2BEheBB7SQnXxwPXt+1hA6XLX87Q2u.wkqvB8Mh7YBs7aCZ\n99GHCxt7MWnrqX44wSDKdhaCdJcDMVgmFDqNOZYwhFORzHaX0J8++pOknC5e\nk2NSusZ5WMV8CejrawNmRKcJi9SwTFh4aOQi0GQD9TLC9vivmulKF6VzRWCW\nkw4QZL+F.X92CX1IENx118nsab2jm9VhcFJ7GWPKU5vRp1kYw8po3CJRquiv\n4aG5sTdxN9P3IUViwartWMd35o0aI0tokMXWqL.Famxc+Knlk9V56bTO.TK\n-----------end_max5_patcher-----------"},{"id":"patch-eb71e1a6-9130-4224-9410-cbd12d48ff42","content":"----------begin_max5_patcher----------\n493.3ocuUEkaaCCC8a6Sgf9pCvsvxIwNdasXWfcBVGFTrU6TPLkgrbW1J5ce\nRTwMIEoNBsF8G4HJJ93i7wnGiinqTaEcTxmI+fDE8XbTDZxYHZ29HZCea0Fd\nG5FED+QsZMMwejQr0flU8FR1f0Vto52R39eoEUFevyxmeUZBgUj49LagaMy9\naxO2cGnuQBaDFDE1di1.OXMcmUYsGxUqujwnNaOEG6VRBjCUpZgyiyltkyvr\ncdp6S9go6cJv.7FAFuu9cEn5Z4Uh5aniwG2sty51gr4XNxNAGSGho2OyeaE9\nrjROJe5j+COf4pwdyNl9b+4ZRGuoci3BIvRHqT8Pci87quk1H0Zk9V5m9xao\nb9JRBIDhhHqDWWNtfH3hU4X0poiatxIaDx4E3SsZe4D1c.ktYDBvJJ12clkO\nQcmhOltiWlS91yRbhWfe1FledmkyFmuYgx27OF9ZmzNuXbhGzVDH0PXnajvK\nelASTm8i4ampWWMDpg+9irOaqEcFIvMREbnSLuSmrlFJRkg.T5D.Td..sbBv\noH.bb4B6chyh.wI8DJCda6CBc2NmQHrZ901gU61xDbqD7aQwIUKdPN3u2BWa\nk7FqduW6esaa9bp+p1geMzKQQbribVHw4I2i23S13EVKMWcu.nwOE+e.WMYF\n5.\n-----------end_max5_patcher-----------"},{"id":"patch-422b7df5-4eb4-4e94-affb-e267f84422d6","content":"----------begin_max5_patcher----------\n487.3ocuU1saiBCDE9Z3ovxW0UhMKlvuq12jppJGXRiyB1HiIKUU8ceMCfZ1\nsQDTCJ4BrlSFmy7YNPdy0gtS0AMTxOIORbbdy0wAk5EbFqcnU7t7RdC1FMWU\nUARC0a36LPmA0AsVoIlCZn4fprf7.T2HJUxuM0YM2jePHe4YMjaFbLHLdiuG\ngk3iKQ3Rf8J4owMIaqDxRvfdy9PT0ZlT8GUEE3bn1c76rszds2cc6u3cijUp\nT+1N2j8V9NwKaAB6GAQQywk+1dRRSVYrB9JXIg+X27mnxZEgMCCwHBAQ3x1H\nrH31QveEQnlq4UDaNCH1CWe+4vgwRwaFwY3BKXdf7uHPrOCT1jmCsYdsFFLj\nRIOsdnBc05qF6FYLEenJNZkHL89P3utdVjw1vxN6SZlGIIbdLCVJlI2GL46Z\nJD62eUXYAIahNG1rvUD136CrB4BdES3.ToqTbMZgng1PKEx++u+vAsW+e4sQ\n0pym9oFCLjOF1BnwHjbiPIOqG6q6vlt3Q5RMJcAFYugRX2nOYKvmjUvm3E5y\nsdtEsvyM+KjK300m.cyXynE1D+QktuLyCKExgRLZR0vIwT+CJbsMvaro8VMN\nVzt3P5vVUEfV1JvHraObVKwmlj7JnolOvA8nvr4EPRce28u.Ss5My.\n-----------end_max5_patcher-----------"}],"content":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    annotation: \"annotation\",\n    code: \"code\",\n    em: \"em\",\n    figcaption: \"figcaption\",\n    figure: \"figure\",\n    h1: \"h1\",\n    h2: \"h2\",\n    h3: \"h3\",\n    img: \"img\",\n    li: \"li\",\n    math: \"math\",\n    mfrac: \"mfrac\",\n    mi: \"mi\",\n    mn: \"mn\",\n    mo: \"mo\",\n    mrow: \"mrow\",\n    p: \"p\",\n    pre: \"pre\",\n    semantics: \"semantics\",\n    span: \"span\",\n    strong: \"strong\",\n    table: \"table\",\n    tbody: \"tbody\",\n    td: \"td\",\n    th: \"th\",\n    thead: \"thead\",\n    tr: \"tr\",\n    ul: \"ul\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      id: \"gen\",\n      children: \"Gen\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Gen is a visual, graph-based programming language. It's syntax is extremely similar to Max, so similar that we program Gen patchers using the Max environment. However, Gen uses a different set of objects from Max—within a \", _jsx(_components.a, {\n        href: \"/reference/gen~\",\n        title: \"gen~\",\n        children: \"gen~\"\n      }), \" subpatcher, you can only use Gen objects.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The main difference between Max and Gen is that while Max works by sending messages between instantiated objects, a Gen patcher is more like a description of how a patcher should be. In order to process audio or computer graphics, a Gen patcher is first used to generate code, which is then compiled and run in the Max environment.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"why-use-gen\",\n      children: \"Why Use Gen?\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"You want to do low-level, visual programming, while still getting the performance of compiled C or GLSL code.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"It's easier to describe your process using text code, but you want to  use \", _jsx(_components.a, {\n            href: \"/reference/gen_common_codebox\",\n            title: \"gen_common_codebox\",\n            children: \"codebox\"\n          }), \", rather than compiling a C object.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"You need single-sample delay for signal processing techniques like filtering, synthesis, and physical modeling.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"You want to design a graphics shader, but you don't want to write GLSL code.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"You want to export your C or GLSL code, for use in an environment other than Max.\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"examples\",\n      children: \"Examples\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"arbitrary new oscillator and filter designs using single-sample feedback loops with \", _jsx(_components.a, {\n            href: \"/reference/gen~\",\n            title: \"gen~\",\n            children: \"gen~\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"reverbs and physical models using networks of short feedback delays with \", _jsx(_components.a, {\n            href: \"/reference/gen~\",\n            title: \"gen~\",\n            children: \"gen~\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"sample-accurate \", _jsx(_components.a, {\n            href: \"/reference/buffer~\",\n            title: \"buffer~\",\n            children: \"buffer~\"\n          }), \" processing such as waveset distortions with \", _jsx(_components.a, {\n            href: \"/reference/gen~\",\n            title: \"gen~\",\n            children: \"gen~\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"efficient frequency-domain processing such as spectral delays using \", _jsx(_components.a, {\n            href: \"/reference/gen~\",\n            title: \"gen~\",\n            children: \"gen~\"\n          }), \" inside \", _jsx(_components.a, {\n            href: \"/reference/pfft~\",\n            title: \"pfft~\",\n            children: \"pfft~\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"custom video processing filters as fast as C compiled externals with \", _jsx(_components.a, {\n            href: \"/reference/jit.pix\",\n            title: \"jit.pix\",\n            children: \"jit.pix\"\n          }), \", and graphics card accelerated with \", _jsx(_components.a, {\n            href: \"/reference/jit.gl.pix\",\n            title: \"jit.gl.pix\",\n            children: \"jit.gl.pix\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"geometry manipulation and generation with \", _jsx(_components.a, {\n            href: \"/reference/jit.gen\",\n            title: \"jit.gen\",\n            children: \"jit.gen\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"particle system design with \", _jsx(_components.a, {\n            href: \"/reference/jit.gen\",\n            title: \"jit.gen\",\n            children: \"jit.gen\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"iso-surface generation with distance fields in \", _jsx(_components.a, {\n            href: \"/reference/jit.gen\",\n            title: \"jit.gen\",\n            children: \"jit.gen\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"performance-improvements\",\n      children: \"Performance Improvements\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"A chain of Gen objects compiles down into one single meta-object, removing the usual overhead that Max encounters when passing messages and signals between objects.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"replacement for \", _jsx(_components.a, {\n            href: \"/reference/jit.expr\",\n            title: \"jit.expr\",\n            children: \"jit.expr\"\n          }), \" with performance and interface improvements\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"You want to be able to have a simple way to make use of the GPU for image processing both in visual and textual form\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"working-with-gen\",\n      children: \"Working with Gen\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Gen patchers are specialized for specific domains such as audio (MSP) and matrix and texture processing (Jitter). The Max Gen object is called \", _jsx(_components.a, {\n        href: \"/reference/gen\",\n        title: \"gen\",\n        children: \"gen\"\n      }), \". The MSP Gen object is called \", _jsx(_components.a, {\n        href: \"/reference/gen~\",\n        title: \"gen~\",\n        children: \"gen~\"\n      }), \". The Jitter Gen objects are \", _jsx(_components.a, {\n        href: \"/reference/jit.gen\",\n        title: \"jit.gen\",\n        children: \"jit.gen\"\n      }), \", \", _jsx(_components.a, {\n        href: \"/reference/jit.pix\",\n        title: \"jit.pix\",\n        children: \"jit.pix\"\n      }), \" and \", _jsx(_components.a, {\n        href: \"/reference/jit.gl.pix\",\n        title: \"jit.gl.pix\",\n        children: \"jit.gl.pix\"\n      }), \". Each of these Gen objects contains within it a Gen patcher. While gen patchers share many of the same capabilities, each Gen object has functionality specific to its domain. For example, Gen patchers in \", _jsx(_components.a, {\n        href: \"/reference/gen~\",\n        title: \"gen~\",\n        children: \"gen~\"\n      }), \" have delay lines while Gen patchers in \", _jsx(_components.a, {\n        href: \"/reference/jit.gen\",\n        title: \"jit.gen\",\n        children: \"jit.gen\"\n      }), \" have vector types.\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: _jsx(_components.a, {\n            href: \"./gen_common_operators.md\",\n            children: \"A listing of operators common to all Gen objects\"\n          })\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: _jsx(_components.a, {\n            href: \"./gen~_operators.md\",\n            children: \"A listing of operators common to all gen~ objects\"\n          })\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: _jsx(_components.a, {\n            href: \"./gen_jitter_operators.md\",\n            children: \"A listing of operators common to all Gen Jitter objects\"\n          })\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"creating-a-gen-patch\",\n      children: \"Creating a Gen Patch\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Create a \", _jsx(_components.a, {\n        href: \"/reference/gen\",\n        title: \"gen\",\n        children: \"gen\"\n      }), \" or \", _jsx(_components.a, {\n        href: \"/reference/gen~\",\n        title: \"gen~\",\n        children: \"gen~\"\n      }), \" object for message and signal processing, and create a \", _jsx(_components.a, {\n        href: \"/reference/jit.gen\",\n        title: \"jit.gen\",\n        children: \"jit.gen\"\n      }), \", \", _jsx(_components.a, {\n        href: \"/reference/jit.pix\",\n        title: \"jit.pix\",\n        children: \"jit.pix\"\n      }), \", or \", _jsx(_components.a, {\n        href: \"/reference/jit.gl.pix\",\n        title: \"jit.gl.pix\",\n        children: \"jit.gl.pix\"\n      }), \" for image processing.\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.a, {\n            href: \"/reference/gen\",\n            title: \"gen\",\n            children: \"gen\"\n          }), \" — create a processing object that runs at message rate, using \", _jsx(_components.a, {\n            href: \"./gen_common_operators.md\",\n            children: \"gen common\"\n          }), \" and \", _jsx(_components.a, {\n            href: \"./gen~_operators.md\",\n            children: \"gen dsp\"\n          }), \" operators.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.a, {\n            href: \"/reference/gen~\",\n            title: \"gen~\",\n            children: \"gen~\"\n          }), \" — create a signal object that runs at signal rate, in Max's DSP chain, using \", _jsx(_components.a, {\n            href: \"./gen_common_operators.md\",\n            children: \"gen common\"\n          }), \" and \", _jsx(_components.a, {\n            href: \"./gen~_operators.md\",\n            children: \"gen dsp\"\n          }), \" operators.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.a, {\n            href: \"/reference/jit.gen\",\n            title: \"jit.gen\",\n            children: \"jit.gen\"\n          }), \" — create a matrix processing object that runs on the CPU. Uses \", _jsx(_components.a, {\n            href: \"./gen_common_operators.md\",\n            children: \"gen common\"\n          }), \" and \", _jsx(_components.a, {\n            href: \"./gen_jitter_operators.md\",\n            children: \"gen jitter\"\n          }), \" operators.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.a, {\n            href: \"/reference/jit.pix\",\n            title: \"jit.pix\",\n            children: \"jit.pix\"\n          }), \" — create a matrix processing object that runs on the CPU, but that's optimized to work on frames of video as opposed to more general matrix types. Always locked to 4 planes, but somewhat more efficient than jit.gen. Uses \", _jsx(_components.a, {\n            href: \"./gen_common_operators.md\",\n            children: \"gen common\"\n          }), \" and \", _jsx(_components.a, {\n            href: \"./gen_jitter_operators.md\",\n            children: \"gen jitter\"\n          }), \" operators.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.a, {\n            href: \"/reference/jit.gl.pix\",\n            title: \"jit.gl.pix\",\n            children: \"jit.gl.pix\"\n          }), \" — create a texture processing object that runs on the GPU. Always locked to 4 planes, but much faster and more efficient than \", _jsx(_components.a, {\n            href: \"/reference/jit.gen\",\n            title: \"jit.gen\",\n            children: \"jit.gen\"\n          }), \" or \", _jsx(_components.a, {\n            href: \"/reference/jit.pix\",\n            title: \"jit.pix\",\n            children: \"jit.pix\"\n          }), \". Compiles to GLSL code, which can be exported and run in other graphics processing environments. Uses \", _jsx(_components.a, {\n            href: \"./gen_common_operators.md\",\n            children: \"gen common\"\n          }), \" and \", _jsx(_components.a, {\n            href: \"./gen_jitter_operators.md\",\n            children: \"gen jitter\"\n          }), \" operators.\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Whichever object you make, you'll get a Gen object that contains a Gen subpatcher. Just like a \", _jsx(_components.a, {\n        href: \"/reference/patcher\",\n        title: \"patcher\",\n        children: \"patcher\"\n      }), \" object, you can double-click on the Gen object to see its contents. When you do, you'll see the default Gen patcher, which simply adds together its inputs.\"]\n    }), \"\\n\", _jsx(_components.p, {}), _jsxs(_components.figure, {\n      \"data-variant\": \"image\",\n      children: [\"\\n\", _jsx(_components.img, {\n        alt: \"\",\n        height: \"473\",\n        src: \"../../userguide/images/c342b0a90756f4b3ac8baa37e47d5898_1280.webp\",\n        srcSet: \"../../userguide/images/c342b0a90756f4b3ac8baa37e47d5898_1280.webp 2x\",\n        title: \"A gen~ object, and its contents\",\n        width: \"640\"\n      }), \"\\n\", _jsx(_components.figcaption, {\n        children: \"A gen~ object, and its contents\"\n      }), \"\\n\"]\n    }), _jsx(_components.p, {}), \"\\n\", _jsxs(_components.p, {\n      children: [\"Gen patchers can be embedded within the \", _jsx(_components.a, {\n        href: \"/reference/gen\",\n        title: \"gen\",\n        children: \"gen\"\n      }), \", \", _jsx(_components.a, {\n        href: \"/reference/gen~\",\n        title: \"gen~\",\n        children: \"gen~\"\n      }), \", \", _jsx(_components.a, {\n        href: \"/reference/jit.gen\",\n        title: \"jit.gen\",\n        children: \"jit.gen\"\n      }), \", etc. object, or can be loaded from external files (with \", _jsx(_components.code, {\n        children: \".gendsp\"\n      }), \" or \", _jsx(_components.code, {\n        children: \".genjit\"\n      }), \" file extensions respectively) using the \", _jsx(_components.code, {\n        children: \"@gen\"\n      }), \" attribute of \", _jsx(_components.a, {\n        href: \"/reference/gen\",\n        title: \"gen\",\n        children: \"gen\"\n      }), \", \", _jsx(_components.a, {\n        href: \"/reference/gen~\",\n        title: \"gen~\",\n        children: \"gen~\"\n      }), \", \", _jsx(_components.a, {\n        href: \"/reference/jit.gen\",\n        title: \"jit.gen\",\n        children: \"jit.gen\"\n      }), \", etc. objects.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"patching-in-gen\",\n      children: \"Patching in Gen\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Patching in Gen should feel very similar to patching in Max. The basic Max paradigms—making objects, connection them—are all the same.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The Gen patcher window has \", _jsx(_components.a, {\n        href: \"../patcher_window.md#gen-window\",\n        children: \"some small differences\"\n      }), \" from the standard Max window, in order to facilitate patching in Gen.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"conceptual-differences-between-max-and-gen\",\n      children: \"Conceptual differences between Max and Gen\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"In Max, objects send messages to each other. In Gen, there are no messages. All operations are synchronous, much like signal flow in Max. Because of this, there are no UI objects (sliders, buttons etc.). However the \", _jsx(_components.a, {\n            href: \"/reference/gen_common_param\",\n            title: \"gen_common_param\",\n            children: \"param\"\n          }), \" operator can be used to receive message-rate controls from the normal Max world. There is no need to differentiate hot and cold inlets, or the order in which outlets \\\"fire\\\", since all objects and outlets always fire at the same time.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"There are no \", _jsx(_components.code, {\n            children: \"send\"\n          }), \" and \", _jsx(_components.code, {\n            children: \"receive\"\n          }), \" operators in Gen patcher. Gen patchers are connected to the outside world through the \", _jsx(_components.a, {\n            href: \"/reference/gen_common_in\",\n            title: \"gen_common_in\",\n            children: \"in\"\n          }), \", \", _jsx(_components.a, {\n            href: \"/reference/gen_common_out\",\n            title: \"gen_common_out\",\n            children: \"out\"\n          }), \", and \", _jsx(_components.a, {\n            href: \"/reference/gen_common_param\",\n            title: \"gen_common_param\",\n            children: \"param\"\n          }), \" operators. In \", _jsx(_components.a, {\n            href: \"/reference/gen~\",\n            title: \"gen~\",\n            children: \"gen~\"\n          }), \", there are some additional operators such as \", _jsx(_components.a, {\n            href: \"/reference/gen_dsp_history\",\n            title: \"gen_dsp_history\",\n            children: \"history\"\n          }), \", \", _jsx(_components.a, {\n            href: \"/reference/gen_dsp_data\",\n            title: \"gen_dsp_data\",\n            children: \"data\"\n          }), \" and \", _jsx(_components.a, {\n            href: \"/reference/gen_dsp_buffer\",\n            title: \"gen_dsp_buffer\",\n            children: \"buffer\"\n          }), \" that are controllable with messages to \", _jsx(_components.a, {\n            href: \"/reference/gen~\",\n            title: \"gen~\",\n            children: \"gen~\"\n          }), \".\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"The usual distinction between int and float numbers does not apply to Gen patchers. At the Gen patcher level, everything is a 64-bit floating point number.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"The \", _jsx(_components.code, {\n            children: \"codebox\"\n          }), \" is a special operator for Gen patchers, in which more complex expressions can be written using the \", _jsx(_components.a, {\n            href: \"./gen_genexpr.md\",\n            children: \"GenExpr\"\n          }), \" language.\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"autocompile\",\n      children: \"Auto-compile\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Remember that Gen patchers must be compiled before they can run. By default, the compilation process occurs in the background while you are editing, so that you can see or hear the results immediately. This auto-compilation process can be disabled using the \", _jsx(_components.em, {\n        children: \"Auto-Compile\"\n      }), \" toggle in the Gen patcher toolbar. With auto-compilation disabled, click the \", _jsx(_components.em, {\n        children: \"Compile\"\n      }), \" icon to compile manually.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"See the \", _jsx(_components.a, {\n        href: \"../patcher_window.md#gen-window\",\n        children: \"Gen patcher differences\"\n      }), \" section of the \", _jsx(_components.a, {\n        href: \"../patcher_window.md\",\n        children: \"Patcher Window\"\n      }), \" guide for more.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"gen-operators\",\n      children: \"Gen Operators\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The fundamental processing object in Max is the Object, and the fundamental processing unit in Gen is the Gen Operator. You can call an operator by creating an object box in Gen, or by calling the operator as a function in \", _jsx(_components.a, {\n        href: \"./gen_genexpr.md\",\n        children: \"GenExpr\"\n      }), \" code.\"]\n    }), \"\\n\", _jsx(_components.p, {}), _jsxs(_components.figure, {\n      \"data-variant\": \"image\",\n      children: [\"\\n\", _jsx(_components.img, {\n        alt: \"\",\n        height: \"241\",\n        src: \"../../userguide/images/4fb374fd8f018cbebc9da942e9738839_960.webp\",\n        srcSet: \"../../userguide/images/4fb374fd8f018cbebc9da942e9738839_960.webp 2x\",\n        title: \"Patching into a change operator is the same as calling the change function in GenExpr\",\n        width: \"480\"\n      }), \"\\n\", _jsx(_components.figcaption, {\n        children: \"Patching into a change operator is the same as calling the change function in GenExpr\"\n      }), \"\\n\"]\n    }), _jsx(_components.p, {}), \"\\n\", _jsxs(_components.p, {\n      children: [\"Gen operators take arguments and attributes just like Max objects, but these are purely declarative. Since there is no messaging in Gen patchers, the attribute value set when the operator is created does not change. Attributes are most often used to specialize the implementation of the process the operator represents (such as setting a maximum value for \", _jsx(_components.code, {\n        children: \"param\"\n      }), \" using the \", _jsx(_components.code, {\n        children: \"@max\"\n      }), \" attribute.)\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In many cases, the specification of an object’s argument effectively replaces the corresponding inlet. This is possible in Gen because there is no messaging and all processing is synchronous. For example, the \", _jsx(_components.code, {\n        children: \"+\"\n      }), \" operator takes two inputs, but if an argument is given only one input needs to be specified as an inlet.\"]\n    }), \"\\n\", _jsx(_components.p, {}), _jsxs(_components.figure, {\n      \"data-variant\": \"image\",\n      children: [\"\\n\", _jsx(_components.img, {\n        alt: \"\",\n        height: \"253\",\n        src: \"../../userguide/images/bf3dce4c98cac66444d34998a56f25b1_558.webp\",\n        srcSet: \"../../userguide/images/bf3dce4c98cac66444d34998a56f25b1_558.webp 2x\",\n        title: \"If the + operator has an argument, it no longer needs a second inlet\",\n        width: \"279\"\n      }), \"\\n\", _jsx(_components.figcaption, {\n        children: \"If the + operator has an argument, it no longer needs a second inlet\"\n      }), \"\\n\"]\n    }), _jsx(_components.p, {}), \"\\n\", _jsx(_components.p, {\n      children: \"An inlet with no connected patchcord uses a default value instead (often zero, but check the inlet assist strings for each operator). An inlet with multiple connections adds them all together, just like with signal patchcords.\"\n    }), \"\\n\", _jsx(_components.p, {}), _jsxs(_components.figure, {\n      \"data-variant\": \"image\",\n      children: [\"\\n\", _jsx(_components.img, {\n        alt: \"\",\n        height: \"266\",\n        src: \"../../userguide/images/2fe2b1256bc71d9e4d35165c34869a7c_782.webp\",\n        srcSet: \"../../userguide/images/2fe2b1256bc71d9e4d35165c34869a7c_782.webp 2x\",\n        title: \"In gen and gen~, two patch cables connected to the same operator inlet will add together.\",\n        width: \"391\"\n      }), \"\\n\", _jsx(_components.figcaption, {\n        children: \"In gen and gen~, two patch cables connected to the same operator inlet will add together.\"\n      }), \"\\n\"]\n    }), _jsx(_components.p, {}), \"\\n\", _jsx(_components.h2, {\n      id: \"standard-operators\",\n      children: \"Standard Operators\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Many standard objects behave like the corresponding Max or MSP object, such as all arithmetic operators (including the reverse operators like \", _jsx(_components.code, {\n        children: \"!-\"\n      }), \", \", _jsx(_components.code, {\n        children: \"!/\"\n      }), \" etc.), trigonometric operators (\", _jsx(_components.code, {\n        children: \"sin\"\n      }), \", \", _jsx(_components.code, {\n        children: \"cosh\"\n      }), \", \", _jsx(_components.code, {\n        children: \"atan2\"\n      }), \" etc.), standard math operators (\", _jsx(_components.code, {\n        children: \"abs\"\n      }), \", \", _jsx(_components.code, {\n        children: \"floor\"\n      }), \", \", _jsx(_components.code, {\n        children: \"pow\"\n      }), \", \", _jsx(_components.code, {\n        children: \"log\"\n      }), \", etc.), boolean operators (\", _jsx(_components.code, {\n        children: \">\"\n      }), \", \", _jsx(_components.code, {\n        children: \"==\"\n      }), \", \", _jsx(_components.code, {\n        children: \"&&\"\n      }), \" (also known as \", _jsx(_components.code, {\n        children: \"and\"\n      }), \") etc.) and other operators such as \", _jsx(_components.code, {\n        children: \"min\"\n      }), \", \", _jsx(_components.code, {\n        children: \"max\"\n      }), \", \", _jsx(_components.code, {\n        children: \"clip\"\n      }), \" (also known as \", _jsx(_components.code, {\n        children: \"clamp\"\n      }), \"), \", _jsx(_components.code, {\n        children: \"scale\"\n      }), \", \", _jsx(_components.code, {\n        children: \"fold\"\n      }), \", \", _jsx(_components.code, {\n        children: \"wrap\"\n      }), \", \", _jsx(_components.code, {\n        children: \"cartopol\"\n      }), \", \", _jsx(_components.code, {\n        children: \"poltocar\"\n      }), \" etc. In addition there are some operators in common with GLSL (\", _jsx(_components.code, {\n        children: \"fract\"\n      }), \", \", _jsx(_components.code, {\n        children: \"mix\"\n      }), \", \", _jsx(_components.code, {\n        children: \"smoothstep\"\n      }), \", \", _jsx(_components.code, {\n        children: \"degrees\"\n      }), \", \", _jsx(_components.code, {\n        children: \"radians\"\n      }), \" etc.) and some drawn from the \", _jsx(_components.a, {\n        href: \"/reference/jit.op\",\n        title: \"jit.op\",\n        children: \"jit.op\"\n      }), \" operator list (\", _jsx(_components.code, {\n        children: \">p\"\n      }), \", \", _jsx(_components.code, {\n        children: \"==p\"\n      }), \", \", _jsx(_components.code, {\n        children: \"absdiff\"\n      }), \" etc.).\\nThere are several predefined constants available (\", _jsx(_components.code, {\n        children: \"pi\"\n      }), \", \", _jsx(_components.code, {\n        children: \"twopi\"\n      }), \", \", _jsx(_components.code, {\n        children: \"halfpi\"\n      }), \", \", _jsx(_components.code, {\n        children: \"invpi\"\n      }), \", \", _jsx(_components.code, {\n        children: \"degtorad\"\n      }), \", \", _jsx(_components.code, {\n        children: \"radtodeg\"\n      }), \", \", _jsx(_components.code, {\n        children: \"e\"\n      }), \", \", _jsx(_components.code, {\n        children: \"ln2\"\n      }), \", \", _jsx(_components.code, {\n        children: \"ln10\"\n      }), \", \", _jsx(_components.code, {\n        children: \"log10e\"\n      }), \", \", _jsx(_components.code, {\n        children: \"log2e\"\n      }), \", \", _jsx(_components.code, {\n        children: \"sqrt2\"\n      }), \", \", _jsx(_components.code, {\n        children: \"sqrt1_2\"\n      }), \" and the same in capitalized form as \", _jsx(_components.code, {\n        children: \"PI\"\n      }), \", \", _jsx(_components.code, {\n        children: \"TWOPI\"\n      }), \" etc), which can be used in place of a numeric argument to any operator.\"]\n    }), \"\\n\", _jsx(_components.p, {}), _jsxs(_components.figure, {\n      \"data-variant\": \"image\",\n      children: [\"\\n\", _jsx(_components.img, {\n        alt: \"\",\n        height: \"167\",\n        src: \"../../userguide/images/29fe909279b13d3a5e01b4eaba075045_474.webp\",\n        srcSet: \"../../userguide/images/29fe909279b13d3a5e01b4eaba075045_474.webp 2x\",\n        title: \"Multiply by the constant pi using twopi or TWOPI.\",\n        width: \"237\"\n      }), \"\\n\", _jsx(_components.figcaption, {\n        children: \"Multiply by the constant pi using twopi or TWOPI.\"\n      }), \"\\n\"]\n    }), _jsx(_components.p, {}), \"\\n\", _jsx(_components.h2, {\n      id: \"argument-expressions\",\n      children: \"Argument Expressions\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For all objects that accept numeric arguments (e.g. \", _jsx(_components.code, {\n        children: \"[+ 2.]\"\n      }), \" or \", _jsx(_components.code, {\n        children: \"[max 1.]\"\n      }), \") argument expressions can be used in their place.  Argument expressions are simple statements with known inputs such as constants, Gen patcher inputs, and parameter names.  Many gen operators can be used as argument expressions, particularly the math operators (\", _jsx(_components.a, {\n        href: \"/reference/gen_common_sqrt\",\n        title: \"gen_common_sqrt\",\n        children: \"sqrt\"\n      }), \", \", _jsx(_components.a, {\n        href: \"/reference/gen_common_cos\",\n        title: \"gen_common_cos\",\n        children: \"cos\"\n      }), \", etc.).  Argument expressions can help simplify Gen patchers where all that is needed is the calculation of a constant that isn't pre-defined, such as \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsxs(_components.mrow, {\n                children: [_jsx(_components.mn, {\n                  children: \"3\"\n                }), _jsx(_components.mo, {\n                  children: \"∗\"\n                }), _jsx(_components.mi, {\n                  children: \"p\"\n                }), _jsx(_components.mi, {\n                  children: \"i\"\n                }), _jsx(_components.mi, {\n                  mathvariant: \"normal\",\n                  children: \"/\"\n                }), _jsx(_components.mn, {\n                  children: \"2\"\n                })]\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"3*pi/2\"\n              })]\n            })\n          })\n        }), _jsxs(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: [_jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.6444em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord\",\n              children: \"3\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2222em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mbin\",\n              children: \"∗\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2222em\"\n              }\n            })]\n          }), _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"1em\",\n                verticalAlign: \"-0.25em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              children: \"p\"\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              children: \"i\"\n            }), _jsx(_components.span, {\n              className: \"mord\",\n              children: \"/2\"\n            })]\n          })]\n        })]\n      }), \".  For example, in the patch below, there is a scale operator with an argument of \", _jsx(_components.code, {\n        children: \"sqrt(2)*2\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {}), _jsxs(_components.figure, {\n      \"data-variant\": \"image\",\n      children: [\"\\n\", _jsx(_components.img, {\n        alt: \"\",\n        height: \"227\",\n        src: \"../../userguide/images/19f693ed1dc6c41cd30e8ebab4b53131_1340.webp\",\n        srcSet: \"../../userguide/images/19f693ed1dc6c41cd30e8ebab4b53131_1340.webp 2x\",\n        title: \"gen_006\",\n        width: \"670\"\n      }), \"\\n\\n\"]\n    }), _jsx(_components.p, {}), \"\\n\", _jsxs(_components.p, {\n      children: [\"Similarly, the mul (*) operator has an argument expression of \", _jsx(_components.code, {\n        children: \"1+in2\"\n      }), \".  Since \", _jsx(_components.code, {\n        children: \"in2\"\n      }), \" is the GenExpr equivalent of \", _jsx(_components.code, {\n        children: \"[in 2]\"\n      }), \", it can be used in an argument expression.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"send-and-receive\",\n      children: \"Send and Receive\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.a, {\n        href: \"/reference/gen_common_send\",\n        title: \"gen_common_send\",\n        children: \"send\"\n      }), \" and \", _jsx(_components.a, {\n        href: \"/reference/gen_common_receive\",\n        title: \"gen_common_receive\",\n        children: \"receive\"\n      }), \" within gen patchers can be used to connect objects without patchcords.  In gen patchers, \", _jsx(_components.a, {\n        href: \"/reference/gen_common_send\",\n        title: \"gen_common_send\",\n        children: \"send\"\n      }), \" and \", _jsx(_components.a, {\n        href: \"/reference/gen_common_receive\",\n        title: \"gen_common_receive\",\n        children: \"receive\"\n      }), \" can only be used locally.  They will not connect to \", _jsx(_components.a, {\n        href: \"/reference/gen_common_send\",\n        title: \"gen_common_send\",\n        children: \"send\"\n      }), \" and \", _jsx(_components.a, {\n        href: \"/reference/gen_common_receive\",\n        title: \"gen_common_receive\",\n        children: \"receive\"\n      }), \" objects in other gen patchers or gen subpatchers.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.a, {\n        href: \"/reference/gen_common_send\",\n        title: \"gen_common_send\",\n        children: \"send\"\n      }), \" and \", _jsx(_components.a, {\n        href: \"/reference/gen_common_receive\",\n        title: \"gen_common_receive\",\n        children: \"receive\"\n      }), \" take a name argument that determines connectivity.\"]\n    }), \"\\n\", _jsxs(_components.figure, {\n      \"data-variant\": \"patcher\",\n      \"data-patch-id\": \"patch-07a24b3a-24a5-4cdf-b4ff-1e70769c7f17\",\n      children: [_jsx(_components.p, {\n        children: _jsx(_components.img, {\n          alt: \"\",\n          height: \"340\",\n          src: \"../../userguide/images/daca0d5db805d49a6f2e6bcad2969066_856.webp\",\n          srcSet: \"../../userguide/images/daca0d5db805d49a6f2e6bcad2969066_856.webp 2x\",\n          title: \"gen_007\",\n          width: \"428\"\n        })\n      }), _jsx(_components.figcaption, {\n        children: \"Using send and receive in a Gen patcher\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"There can be multiple \", _jsx(_components.a, {\n        href: \"/reference/gen_common_send\",\n        title: \"gen_common_send\",\n        children: \"send\"\n      }), \" and \", _jsx(_components.a, {\n        href: \"/reference/gen_common_receive\",\n        title: \"gen_common_receive\",\n        children: \"receive\"\n      }), \" objects with the same name without issue.  If there are multiple \", _jsx(_components.a, {\n        href: \"/reference/gen_common_send\",\n        title: \"gen_common_send\",\n        children: \"send\"\n      }), \" objects with the same name, they will be summed just as if multiple patchcords were connected to the same inlet.  If there are multiple \", _jsx(_components.a, {\n        href: \"/reference/gen_common_receive\",\n        title: \"gen_common_receive\",\n        children: \"receive\"\n      }), \" objects with the same name, they will all receive identical input from their corresponding \", _jsx(_components.a, {\n        href: \"/reference/gen_common_send\",\n        title: \"gen_common_send\",\n        children: \"send\"\n      }), \" objects.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"subpatchers-and-abstractions\",\n      children: \"Subpatchers and Abstractions\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Subpatchers and abstraction in Gen objects behave practically identically to standard Max subpatchers and abstractions.  In Gen objects, subpatchers are created with the \", _jsx(_components.a, {\n        href: \"/reference/gen_common_gen\",\n        title: \"gen_common_gen\",\n        children: \"gen\"\n      }), \" operator.  If the \", _jsx(_components.a, {\n        href: \"/reference/gen_common_gen\",\n        title: \"gen_common_gen\",\n        children: \"gen\"\n      }), \" operator is given the name of a Gen patcher as an argument, it will use it to set the titlebar of the subpatcher.\"]\n    }), \"\\n\", _jsxs(_components.figure, {\n      \"data-variant\": \"patcher\",\n      \"data-patch-id\": \"patch-1bd4c24f-d3a9-4a03-860a-f6ec3143bb9a\",\n      children: [_jsx(_components.p, {\n        children: _jsx(_components.img, {\n          alt: \"\",\n          height: \"443\",\n          src: \"../../userguide/images/09f84d3d8709e9627b7328be28ab89b3_1096.webp\",\n          srcSet: \"../../userguide/images/09f84d3d8709e9627b7328be28ab89b3_1096.webp 2x\",\n          title: \"gen_008\",\n          width: \"548\"\n        })\n      }), _jsx(_components.figcaption, {\n        children: \"Using the gen operator to make subpatchers in Gen\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Abstractions, as with standard max abstractions, are created by saving a Gen patcher, then instantiated by creating an object with the name of the saved Gen file to load as the abstraction.  For example, if an operator named \", _jsx(_components.code, {\n        children: \"differential\"\n      }), \" is created, gen will look for the file \", _jsx(_components.code, {\n        children: \"differential.gendsp\"\n      }), \" with \", _jsx(_components.a, {\n        href: \"/reference/gen~\",\n        title: \"gen~\",\n        children: \"gen~\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"differential.genjit\"\n      }), \" with the Jitter Gen objects.  Instantiating abstractions this way is shorthand for setting the \", _jsx(_components.code, {\n        children: \"@file\"\n      }), \" attribute on the \", _jsx(_components.a, {\n        href: \"/reference/gen_common_gen\",\n        title: \"gen_common_gen\",\n        children: \"gen\"\n      }), \" operator.  For example, creating an operator \", _jsx(_components.code, {\n        children: \"differential\"\n      }), \" is equivalent to \", _jsx(_components.code, {\n        children: \"gen @file differential\"\n      }), \". Abstractions of \", _jsx(_components.a, {\n        href: \"/reference/gen~\",\n        title: \"gen~\",\n        children: \"gen~\"\n      }), \" and \", _jsx(_components.a, {\n        href: \"/reference/gen\",\n        title: \"gen\",\n        children: \"gen\"\n      }), \" patchers save with the \", _jsx(_components.code, {\n        children: \".gendsp\"\n      }), \" file extension and abstractions of \", _jsx(_components.a, {\n        href: \"/reference/jit.gen\",\n        title: \"jit.gen\",\n        children: \"jit.gen\"\n      }), \", \", _jsx(_components.a, {\n        href: \"/reference/jit.pix\",\n        title: \"jit.pix\",\n        children: \"jit.pix\"\n      }), \" and \", _jsx(_components.a, {\n        href: \"/reference/jit.gl.pix\",\n        title: \"jit.gl.pix\",\n        children: \"jit.gl.pix\"\n      }), \" save with the \", _jsx(_components.code, {\n        children: \".genjit\"\n      }), \" file extension.\"]\n    }), \"\\n\", _jsx(_components.p, {}), _jsxs(_components.figure, {\n      \"data-variant\": \"image\",\n      children: [\"\\n\", _jsx(_components.img, {\n        alt: \"\",\n        height: \"459\",\n        src: \"../../userguide/images/049a8812574065451a37c4767664f553_1120.webp\",\n        srcSet: \"../../userguide/images/049a8812574065451a37c4767664f553_1120.webp 2x\",\n        title: \"gen_009\",\n        width: \"560\"\n      }), \"\\n\\n\"]\n    }), _jsx(_components.p, {}), \"\\n\", _jsx(_components.figure, {\n      \"data-variant\": \"callout\",\n      \"data-level\": \"info\",\n      children: _jsxs(_components.p, {\n        children: [\"Save a Gen abstraction by choosing \", _jsx(_components.em, {\n          children: \"Save As...\"\n        }), \" from the \", _jsx(_components.em, {\n          children: \"File\"\n        }), \" menu when focused on a Gen subpatcher.\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"subpatcherabstractions-and-parameters\",\n      children: \"Subpatcher/Abstractions and Parameters\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Just like normal gen patchers, Gen subpatchers and abstractions can also contain parameters.  When used in subpatchers and abstractions, parameters behave like named inlets with default values.  If nothing is connected to a parameter in a subpatcher or abstraction, the parameter will be a constant and its value will be its default.\"\n    }), \"\\n\", _jsx(_components.p, {}), _jsxs(_components.figure, {\n      \"data-variant\": \"image\",\n      children: [\"\\n\", _jsx(_components.img, {\n        alt: \"\",\n        height: \"416\",\n        src: \"../../userguide/images/52fc2dbac7f096401d71128ba408d1d7_1290.webp\",\n        srcSet: \"../../userguide/images/52fc2dbac7f096401d71128ba408d1d7_1290.webp 2x\",\n        title: \"gen_010\",\n        width: \"645\"\n      }), \"\\n\\n\"]\n    }), _jsx(_components.p, {}), \"\\n\", _jsxs(_components.p, {\n      children: [\"In the above example, the subpatcher has a parameter \", _jsx(_components.code, {\n        children: \"@scale\"\n      }), \" with a default of 1.  In the subpatcher's sidebar, we see this represented in the \", _jsx(_components.a, {\n        href: \"gen_genexpr.md\",\n        children: \"GenExpr\"\n      }), \" code as\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [\"Param scale(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \".);\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"However, in the parent Gen patcher, the parameter gets converted into a constant because nothing is connected to the parameter.\"\n    }), \"\\n\", _jsx(_components.p, {}), _jsxs(_components.figure, {\n      \"data-variant\": \"image\",\n      children: [\"\\n\", _jsx(_components.img, {\n        alt: \"\",\n        height: \"379\",\n        src: \"../../userguide/images/418acba52d63e59872875e9ef7b0f348_1132.webp\",\n        srcSet: \"../../userguide/images/418acba52d63e59872875e9ef7b0f348_1132.webp 2x\",\n        title: \"gen_012\",\n        width: \"566\"\n      }), \"\\n\\n\"]\n    }), _jsx(_components.p, {}), \"\\n\", _jsx(_components.p, {\n      children: \"The first line in the parent patcher's GenExpr sidebar reads:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [\"scale_1 \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \".;\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This sets the \", _jsx(_components.code, {\n        children: \"@scale\"\n      }), \" parameter to a constant value.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Since subpatcher and abstraction parameters don't create their own inlets to connect objects to, there is a special operator called \", _jsx(_components.a, {\n        href: \"/reference/gen_common_setparam\",\n        title: \"gen_common_setparam\",\n        children: \"setparam\"\n      }), \" that can be connected to any inlet for this specific purposes. \", _jsx(_components.a, {\n        href: \"/reference/gen_common_setparam\",\n        title: \"gen_common_setparam\",\n        children: \"setparam\"\n      }), \" connects all of its inputs to a named parameter in a subpatcher or abstraction.  It requires an argument specifying the name of the parameter to connect to.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"When \", _jsx(_components.a, {\n        href: \"/reference/gen_common_setparam\",\n        title: \"gen_common_setparam\",\n        children: \"setparam\"\n      }), \" is connected to a parameter, the parameter changes from being a constant to a dynamic variable equivalent to the value at the input of the \", _jsx(_components.a, {\n        href: \"/reference/gen_common_setparam\",\n        title: \"gen_common_setparam\",\n        children: \"setparam\"\n      }), \" object.\"]\n    }), \"\\n\", _jsx(_components.p, {}), _jsxs(_components.figure, {\n      \"data-variant\": \"image\",\n      children: [\"\\n\", _jsx(_components.img, {\n        alt: \"\",\n        height: \"593\",\n        src: \"../../userguide/images/f6dc948cae126a065bc0ea31157a34e4_2048.webp\",\n        srcSet: \"../../userguide/images/f6dc948cae126a065bc0ea31157a34e4_2048.webp 2x\",\n        title: \"gen_013\",\n        width: \"1024\"\n      }), \"\\n\\n\"]\n    }), _jsx(_components.p, {}), \"\\n\", _jsx(_components.p, {\n      children: \"Notice that the code in the parent subpatcher has changed from a constant to:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [\"setparam_1 \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in2\"\n        }), \";\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"in\"\n      }), \" is conected to the inlet of the \", _jsx(_components.a, {\n        href: \"/reference/gen_common_setparam\",\n        title: \"gen_common_setparam\",\n        children: \"setparam\"\n      }), \" object so the scale parameter takes on that value.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"setting-parameter-defaults\",\n      children: \"Setting Parameter Defaults\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The default value for \", _jsx(_components.a, {\n        href: \"/reference/gen_common_param\",\n        title: \"gen_common_param\",\n        children: \"param\"\n      }), \" objects within Gen patchers and subpatchers can be set either directly in the \", _jsx(_components.a, {\n        href: \"/reference/gen_common_param\",\n        title: \"gen_common_param\",\n        children: \"param\"\n      }), \" object in the form \", _jsx(_components.code, {\n        children: \"param paramnamevalue(s)\"\n      }), \" or in the containing \", _jsx(_components.a, {\n        href: \"/reference/gen~\",\n        title: \"gen~\",\n        children: \"gen~\"\n      }), \" object box in the form \", _jsx(_components.code, {\n        children: \"gen~ @paramname value(s)\"\n      }), \". If a default is declared in both the \", _jsx(_components.a, {\n        href: \"/reference/gen_common_param\",\n        title: \"gen_common_param\",\n        children: \"param\"\n      }), \" object and in the containing gen object box, the object box will override the value declared in the \", _jsx(_components.a, {\n        href: \"/reference/gen_common_param\",\n        title: \"gen_common_param\",\n        children: \"param\"\n      }), \" object.\"]\n    }), \"\\n\", _jsx(_components.p, {}), _jsxs(_components.figure, {\n      \"data-variant\": \"image\",\n      children: [\"\\n\", _jsx(_components.img, {\n        alt: \"\",\n        height: \"353\",\n        src: \"../../userguide/images/8b6ef50ddbeb685212ee57203113b5f4_1008.webp\",\n        srcSet: \"../../userguide/images/8b6ef50ddbeb685212ee57203113b5f4_1008.webp 2x\",\n        title: \"The parameter value @foo 21 in the top level overrides the default value of 74.\",\n        width: \"504\"\n      }), \"\\n\", _jsx(_components.figcaption, {\n        children: \"The parameter value @foo 21 in the top level overrides the default value of 74.\"\n      }), \"\\n\"]\n    }), _jsx(_components.p, {}), \"\\n\", _jsxs(_components.p, {\n      children: [\"This also applies to Gen subpatchers and abstractions; however, object box declared values only go one patcher deep. So \", _jsx(_components.code, {\n        children: \"gen~ @foo 10\"\n      }), \" would set the default for any \", _jsx(_components.a, {\n        href: \"/reference/gen_common_param\",\n        title: \"gen_common_param\",\n        children: \"param\"\n      }), \" object named \", _jsx(_components.code, {\n        children: \"foo\"\n      }), \" in the top-level \", _jsx(_components.a, {\n        href: \"/reference/gen~\",\n        title: \"gen~\",\n        children: \"gen~\"\n      }), \" patcher, but not \", _jsx(_components.a, {\n        href: \"/reference/gen_common_param\",\n        title: \"gen_common_param\",\n        children: \"param\"\n      }), \" objects named \", _jsx(_components.code, {\n        children: \"foo\"\n      }), \" contained in Gen subpatchers and abstractions.\"]\n    }), \"\\n\", _jsx(_components.p, {}), _jsxs(_components.figure, {\n      \"data-variant\": \"image\",\n      children: [\"\\n\", _jsx(_components.img, {\n        alt: \"\",\n        height: \"339\",\n        src: \"../../userguide/images/7cbc38e2074638ab4524b9924a66e172_1666.webp\",\n        srcSet: \"../../userguide/images/7cbc38e2074638ab4524b9924a66e172_1666.webp 2x\",\n        title: \"gen_015\",\n        width: \"833\"\n      }), \"\\n\\n\"]\n    }), _jsx(_components.p, {}), \"\\n\", _jsx(_components.h2, {\n      id: \"the-gen~-object\",\n      children: \"The gen~ Object\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.a, {\n        href: \"/reference/gen~\",\n        title: \"gen~\",\n        children: \"gen~\"\n      }), \" object is specifically for operating on MSP audio signals. Unlike MSP patching however, operations in a Gen patcher are combined into a single chunk of machine code, making possible many more optimizations that can make complex processes more efficient, and allow you to design processes which must operate on a per-sample level, even with feedback loops.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Working in \", _jsx(_components.a, {\n        href: \"/reference/gen~\",\n        title: \"gen~\",\n        children: \"gen~\"\n      }), \" opens up scope to design signal processes at a lower level, even per-sample. Because of this, many operators take duration arguments in terms of samples (where the equivalent MSP objects would use milliseconds).\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"gen~-operators\",\n      children: \"gen~ Operators\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In addition to the standard Gen operators , which are often similar to the equivalent MSP objects (such as \", _jsx(_components.code, {\n        children: \"clip\"\n      }), \", \", _jsx(_components.code, {\n        children: \"scale\"\n      }), \", \", _jsx(_components.code, {\n        children: \"minimum\"\n      }), \", \", _jsx(_components.code, {\n        children: \"maximum\"\n      }), \", etc.), many of the operators specific to the \", _jsx(_components.a, {\n        href: \"/reference/gen~\",\n        title: \"gen~\",\n        children: \"gen~\"\n      }), \" domain mirror existing MSP objects to make the transition to \", _jsx(_components.a, {\n        href: \"/reference/gen~\",\n        title: \"gen~\",\n        children: \"gen~\"\n      }), \" easier. There are familiar converters (\", _jsx(_components.code, {\n        children: \"dbtoa\"\n      }), \", \", _jsx(_components.code, {\n        children: \"atodb\"\n      }), \", \", _jsx(_components.code, {\n        children: \"mtof\"\n      }), \", \", _jsx(_components.code, {\n        children: \"ftom\"\n      }), \", \", _jsx(_components.code, {\n        children: \"mstosamps\"\n      }), \", \", _jsx(_components.code, {\n        children: \"sampstoms\"\n      }), \"), oscillators (\", _jsx(_components.code, {\n        children: \"phasor\"\n      }), \", \", _jsx(_components.code, {\n        children: \"train\"\n      }), \", \", _jsx(_components.code, {\n        children: \"cycle\"\n      }), \", \", _jsx(_components.code, {\n        children: \"noise\"\n      }), \"), and modifiers (\", _jsx(_components.code, {\n        children: \"delta\"\n      }), \", \", _jsx(_components.code, {\n        children: \"change\"\n      }), \", \", _jsx(_components.code, {\n        children: \"sah\"\n      }), \", \", _jsx(_components.code, {\n        children: \"triangle\"\n      }), \"). In addition there are some lower-level operators to avoid invalid or inaudible outputs (\", _jsx(_components.code, {\n        children: \"isnan\"\n      }), \", \", _jsx(_components.code, {\n        children: \"fixnan\"\n      }), \", \", _jsx(_components.code, {\n        children: \"isdenorm\"\n      }), \", \", _jsx(_components.code, {\n        children: \"fixdenorm\"\n      }), \", \", _jsx(_components.code, {\n        children: \"dcblock\"\n      }), \").\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"A global value of \", _jsx(_components.code, {\n        children: \"samplerate\"\n      }), \" is available both as an object, and as a valid value for an argument of any object.\"]\n    }), \"\\n\", _jsxs(_components.figure, {\n      \"data-variant\": \"patcher\",\n      \"data-patch-id\": \"patch-c3e1bb92-0bea-4416-97e1-d0876e37615f\",\n      children: [_jsx(_components.p, {\n        children: _jsx(_components.img, {\n          alt: \"\",\n          height: \"223\",\n          src: \"../../userguide/images/476f79543926c55079c01ec2ffbe3b10_1050.webp\",\n          srcSet: \"../../userguide/images/476f79543926c55079c01ec2ffbe3b10_1050.webp 2x\",\n          title: \"gen_016\",\n          width: \"525\"\n        })\n      }), _jsx(_components.figcaption, {\n        children: \"The samplerate value is available as an object and as a constant in codebox\"\n      })]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"history\",\n      children: \"History\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In general, the Gen patcher will not allow a feedback loop (since it represents a synchronous process). To create a feedback loop in \", _jsx(_components.a, {\n        href: \"/reference/gen~\",\n        title: \"gen~\",\n        children: \"gen~\"\n      }), \", the \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_history\",\n        title: \"gen_dsp_history\",\n        children: \"history\"\n      }), \" operator can be used. This represents a single-sample delay (a \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsxs(_components.mrow, {\n                children: [_jsx(_components.mi, {\n                  children: \"Z\"\n                }), _jsx(_components.mo, {\n                  children: \"−\"\n                }), _jsx(_components.mn, {\n                  children: \"1\"\n                })]\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"Z-1\"\n              })]\n            })\n          })\n        }), _jsxs(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: [_jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.7667em\",\n                verticalAlign: \"-0.0833em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              style: {\n                marginRight: \"0.07153em\"\n              },\n              children: \"Z\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2222em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mbin\",\n              children: \"−\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2222em\"\n              }\n            })]\n          }), _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.6444em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord\",\n              children: \"1\"\n            })]\n          })]\n        })]\n      }), \" operation). Thus the inlet to the \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_history\",\n        title: \"gen_dsp_history\",\n        children: \"history\"\n      }), \" operator will set the outlet value for the next sample (put another way, the outlet value of the \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_history\",\n        title: \"gen_dsp_history\",\n        children: \"history\"\n      }), \" operator is the inlet value from the previous sample). Multiple \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_history\",\n        title: \"gen_dsp_history\",\n        children: \"history\"\n      }), \" operators can be chained to create \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsxs(_components.mrow, {\n                children: [_jsx(_components.mi, {\n                  children: \"Z\"\n                }), _jsx(_components.mo, {\n                  children: \"−\"\n                }), _jsx(_components.mn, {\n                  children: \"2\"\n                })]\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"Z-2\"\n              })]\n            })\n          })\n        }), _jsxs(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: [_jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.7667em\",\n                verticalAlign: \"-0.0833em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              style: {\n                marginRight: \"0.07153em\"\n              },\n              children: \"Z\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2222em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mbin\",\n              children: \"−\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2222em\"\n              }\n            })]\n          }), _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.6444em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord\",\n              children: \"2\"\n            })]\n          })]\n        })]\n      }), \", \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsxs(_components.mrow, {\n                children: [_jsx(_components.mi, {\n                  children: \"Z\"\n                }), _jsx(_components.mo, {\n                  children: \"−\"\n                }), _jsx(_components.mn, {\n                  children: \"3\"\n                })]\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"Z-3\"\n              })]\n            })\n          })\n        }), _jsxs(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: [_jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.7667em\",\n                verticalAlign: \"-0.0833em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord mathnormal\",\n              style: {\n                marginRight: \"0.07153em\"\n              },\n              children: \"Z\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2222em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mbin\",\n              children: \"−\"\n            }), _jsx(_components.span, {\n              className: \"mspace\",\n              style: {\n                marginRight: \"0.2222em\"\n              }\n            })]\n          }), _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"0.6444em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord\",\n              children: \"3\"\n            })]\n          })]\n        })]\n      }), \" delays, but for longer and more flexible delay operators, use the \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_delay\",\n        title: \"gen_dsp_delay\",\n        children: \"delay\"\n      }), \" operator.\"]\n    }), \"\\n\", _jsxs(_components.figure, {\n      \"data-variant\": \"patcher\",\n      \"data-patch-id\": \"patch-4a056bd7-3012-466b-bc3c-e59205bb42ac\",\n      children: [_jsx(_components.p, {\n        children: _jsx(_components.img, {\n          alt: \"\",\n          height: \"257\",\n          src: \"../../userguide/images/3f4e740fd9a637399f03ecf20c44756b_1044.webp\",\n          srcSet: \"../../userguide/images/3f4e740fd9a637399f03ecf20c44756b_1044.webp 2x\",\n          title: \"gen_017\",\n          width: \"522\"\n        })\n      }), _jsx(_components.figcaption, {\n        children: \"You can use the History operator as an object or in codebox.\"\n      })]\n    }), \"\\n\", _jsx(_components.figure, {\n      \"data-variant\": \"callout\",\n      \"data-level\": \"info\",\n      children: _jsxs(_components.p, {\n        children: [\"A history operator in a Gen patcher can also be named, making it available for external control, just like a \", _jsx(_components.a, {\n          href: \"/reference/gen_common_param\",\n          title: \"gen_common_param\",\n          children: \"param\"\n        }), \" parameter.\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"delay\",\n      children: \"Delay\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_delay\",\n        title: \"gen_dsp_delay\",\n        children: \"delay\"\n      }), \" operator delays a signal by a certain amount of time, specified in samples. The maximum delay time is specified as an argument to the \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_delay\",\n        title: \"gen_dsp_delay\",\n        children: \"delay\"\n      }), \" object. You can also have a multi-tap delay by specifying the number of taps in the second argument. Each tap will have an inlet to set the delay time, and a corresponding outlet for the delayed signal.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_delay\",\n        title: \"gen_dsp_delay\",\n        children: \"delay\"\n      }), \" operator can be used for feedback loops, like the history operator, if the \", _jsx(_components.code, {\n        children: \"@feedback\"\n      }), \" attribute is set to 1 (the default). The \", _jsx(_components.code, {\n        children: \"@interp\"\n      }), \" attribute specifies which kind of interpolation is used:\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"none\"\n        }), \" or \", _jsx(_components.strong, {\n          children: \"step\"\n        }), \" : No interpolation.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"linear\"\n        }), \" : Linear interpolation.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"cosine\"\n        }), \" : Cosine interpolation.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"cubic\"\n        }), \" : Cubic interpolation.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"spline\"\n        }), \" : Catmull-Rom spline interpolation.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"data-and-buffer\",\n      children: \"Data and Buffer\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For more complex persistent storage of audio (or any numeric) data, \", _jsx(_components.a, {\n        href: \"/reference/gen~\",\n        title: \"gen~\",\n        children: \"gen~\"\n      }), \" offers two objects: \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_data\",\n        title: \"gen_dsp_data\",\n        children: \"data\"\n      }), \" and \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_buffer\",\n        title: \"gen_dsp_buffer\",\n        children: \"buffer\"\n      }), \", which are in some ways similar to MSP’s \", _jsx(_components.a, {\n        href: \"/reference/buffer~\",\n        title: \"buffer~\",\n        children: \"buffer~\"\n      }), \" object. A \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_data\",\n        title: \"gen_dsp_data\",\n        children: \"data\"\n      }), \" or \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_buffer\",\n        title: \"gen_dsp_buffer\",\n        children: \"buffer\"\n      }), \" object has a local name, which is used by various operators in the Gen patcher to read and write the \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_data\",\n        title: \"gen_dsp_data\",\n        children: \"data\"\n      }), \" or \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_buffer\",\n        title: \"gen_dsp_buffer\",\n        children: \"buffer\"\n      }), \" contents, or get its properties.\"]\n    }), \"\\n\", _jsx(_components.p, {}), _jsxs(_components.figure, {\n      \"data-variant\": \"image\",\n      children: [\"\\n\", _jsx(_components.img, {\n        alt: \"\",\n        height: \"177\",\n        src: \"../../userguide/images/474543e9936bcb7e8baca91f42ecbbb0_912.webp\",\n        srcSet: \"../../userguide/images/474543e9936bcb7e8baca91f42ecbbb0_912.webp 2x\",\n        title: \"gen_018\",\n        width: \"456\"\n      }), \"\\n\\n\"]\n    }), _jsx(_components.p, {}), \"\\n\", _jsxs(_components.p, {\n      children: [\"Reading the contents of a \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_data\",\n        title: \"gen_dsp_data\",\n        children: \"data\"\n      }), \" or \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_buffer\",\n        title: \"gen_dsp_buffer\",\n        children: \"buffer\"\n      }), \" can be done using the \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_peek\",\n        title: \"gen_dsp_peek\",\n        children: \"peek\"\n      }), \", \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_lookup\",\n        title: \"gen_dsp_lookup\",\n        children: \"lookup\"\n      }), \", \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_wave\",\n        title: \"gen_dsp_wave\",\n        children: \"wave\"\n      }), \", \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_sample\",\n        title: \"gen_dsp_sample\",\n        children: \"sample\"\n      }), \" or \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_nearest\",\n        title: \"gen_dsp_nearest\",\n        children: \"nearest\"\n      }), \" operators. The first argument for all of these operators is the local name of a \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_data\",\n        title: \"gen_dsp_data\",\n        children: \"data\"\n      }), \" or \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_buffer\",\n        title: \"gen_dsp_buffer\",\n        children: \"buffer\"\n      }), \". They all support single- or multi-channel reading (the second argument specifies the number of channels, and the last inlet the channel offset, where zero is the default).\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"All of these operators are essentially the same, differing only in defaults of their attributes. The attributes are:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"index\"\n          }), \" specifies the meaning of the first inlet:\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"samples\"\n          }), \" : The first inlet is a sample index into the \", _jsx(_components.a, {\n            href: \"/reference/gen_dsp_data\",\n            title: \"gen_dsp_data\",\n            children: \"data\"\n          }), \" or \", _jsx(_components.a, {\n            href: \"/reference/gen_dsp_buffer\",\n            title: \"gen_dsp_buffer\",\n            children: \"buffer\"\n          }), \".\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"phase\"\n          }), \" : Maps the range 0..1 to the whole \", _jsx(_components.a, {\n            href: \"/reference/gen_dsp_data\",\n            title: \"gen_dsp_data\",\n            children: \"data\"\n          }), \" or \", _jsx(_components.a, {\n            href: \"/reference/gen_dsp_buffer\",\n            title: \"gen_dsp_buffer\",\n            children: \"buffer\"\n          }), \" contents.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"lookup\"\n          }), \" or \", _jsx(_components.strong, {\n            children: \"signal\"\n          }), \" : Maps the range -1..1 to the whole \", _jsx(_components.a, {\n            href: \"/reference/gen_dsp_data\",\n            title: \"gen_dsp_data\",\n            children: \"data\"\n          }), \" or \", _jsx(_components.a, {\n            href: \"/reference/gen_dsp_buffer\",\n            title: \"gen_dsp_buffer\",\n            children: \"buffer\"\n          }), \" contents, like the MSP \", _jsx(_components.a, {\n            href: \"/reference/lookup~\",\n            title: \"lookup~\",\n            children: \"lookup~\"\n          }), \" object.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"wave\"\n          }), \" : Adds extra inlets for start/end (in samples), driven by a phase signal between these boundaries (0..1, similar to MSP’s \", _jsx(_components.a, {\n            href: \"/reference/wave~\",\n            title: \"wave~\",\n            children: \"wave~\"\n          }), \" object).\\n\", _jsx(_components.code, {\n            children: \"@boundmode\"\n          }), \" specifies what to do if the index is out of range:\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"ignore\"\n          }), \" : Indices out of bounds are ignored (return zero).\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"wrap\"\n          }), \" : Indices out of bounds repeat at the opposite boundary.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"fold\"\n          }), \" or \", _jsx(_components.strong, {\n            children: \"mirror\"\n          }), \" : Indices wrap with palindrome behavior.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"clip\"\n          }), \" or \", _jsx(_components.strong, {\n            children: \"clamp\"\n          }), \" : Indices out of bounds use the value at the bound.\\n\", _jsx(_components.code, {\n            children: \"@channelmode\"\n          }), \" specifies what to do if the channel is out of range. It has the same options as the \", _jsx(_components.code, {\n            children: \"@boundmode\"\n          }), \" attribute.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"interp\"\n          }), \" specifies what kind of interpolation is used:\"]\n        }), \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"none\"\n            }), \" or \", _jsx(_components.strong, {\n              children: \"step\"\n            }), \" : No interpolation.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"linear\"\n            }), \" : Linear interpolation.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"cosine\"\n            }), \" : Cosine interpolation.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"cubic\"\n            }), \" : Cubic interpolation.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"spline\"\n            }), \" : Catmull-Rom spline interpolation.\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"Operator\"\n          }), _jsx(_components.th, {\n            children: \"Defaults\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.a, {\n              href: \"/reference/gen_dsp_nearest\",\n              title: \"gen_dsp_nearest\",\n              children: \"nearest\"\n            })\n          }), _jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"@index phase @interp none @boundmode ignore @channelmode ignore\"\n            })\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.a, {\n              href: \"/reference/gen_dsp_sample\",\n              title: \"gen_dsp_sample\",\n              children: \"sample\"\n            })\n          }), _jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"@index phase @interp linear @boundmode ignore @channelmode ignore\"\n            })\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.a, {\n              href: \"/reference/gen_dsp_peek\",\n              title: \"gen_dsp_peek\",\n              children: \"peek\"\n            })\n          }), _jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"@index samples @interp none @boundmode ignore @channelmode ignore\"\n            })\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.a, {\n              href: \"/reference/gen_dsp_lookup\",\n              title: \"gen_dsp_lookup\",\n              children: \"lookup\"\n            })\n          }), _jsx(_components.td, {\n            children: \"`@index lookup @interp linear @boundmode clamp @channelmode clamp\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.a, {\n              href: \"/reference/gen_dsp_wave\",\n              title: \"gen_dsp_wave\",\n              children: \"wave\"\n            })\n          }), _jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"@index wave @interp linear @boundmode wrap @channelmode clamp\"\n            })\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Accessing the spatial properties of a \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_data\",\n        title: \"gen_dsp_data\",\n        children: \"data\"\n      }), \" or \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_buffer\",\n        title: \"gen_dsp_buffer\",\n        children: \"buffer\"\n      }), \" objects is done using the \", _jsx(_components.code, {\n        children: \"dim\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"channels\"\n      }), \" operators (or the outlets of the \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_data\",\n        title: \"gen_dsp_data\",\n        children: \"data\"\n      }), \" or \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_buffer\",\n        title: \"gen_dsp_buffer\",\n        children: \"buffer\"\n      }), \" object itself), and writing is done using \", _jsx(_components.code, {\n        children: \"poke\"\n      }), \" (non-interpolating replace) or \", _jsx(_components.code, {\n        children: \"splat\"\n      }), \" (interpolating overdub).\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Briefly, \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_data\",\n        title: \"gen_dsp_data\",\n        children: \"data\"\n      }), \" should be thought of as a 64-bit buffer internal to the \", _jsx(_components.a, {\n        href: \"/reference/gen~\",\n        title: \"gen~\",\n        children: \"gen~\"\n      }), \" patcher, even though it can be copied to, and \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_buffer\",\n        title: \"gen_dsp_buffer\",\n        children: \"buffer\"\n      }), \" should be thought of as an object which can read and write external \", _jsx(_components.a, {\n        href: \"/reference/buffer~\",\n        title: \"buffer~\",\n        children: \"buffer~\"\n      }), \" data. The full differences between \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_data\",\n        title: \"gen_dsp_data\",\n        children: \"data\"\n      }), \" and \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_buffer\",\n        title: \"gen_dsp_buffer\",\n        children: \"buffer\"\n      }), \" are:\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"A \", _jsx(_components.a, {\n            href: \"/reference/gen_dsp_data\",\n            title: \"gen_dsp_data\",\n            children: \"data\"\n          }), \" object is local to the Gen patcher, and cannot be read outside of it. On the other hand, a \", _jsx(_components.a, {\n            href: \"/reference/gen_dsp_buffer\",\n            title: \"gen_dsp_buffer\",\n            children: \"buffer\"\n          }), \" object is a shared reference to an external MSP \", _jsx(_components.a, {\n            href: \"/reference/buffer~\",\n            title: \"buffer~\",\n            children: \"buffer~\"\n          }), \" object. Modifying the contents in a Gen buffer is directly modifying the contents of the MSP \", _jsx(_components.a, {\n            href: \"/reference/buffer~\",\n            title: \"buffer~\",\n            children: \"buffer~\"\n          }), \" object it references.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"The \", _jsx(_components.a, {\n            href: \"/reference/gen_dsp_data\",\n            title: \"gen_dsp_data\",\n            children: \"data\"\n          }), \" object takes three arguments to set its local name, its length (in samples) and number of channels. The \", _jsx(_components.a, {\n            href: \"/reference/gen_dsp_buffer\",\n            title: \"gen_dsp_buffer\",\n            children: \"buffer\"\n          }), \" object takes an argument to set its local name, and an optional argument to specify the name of an MSP \", _jsx(_components.a, {\n            href: \"/reference/buffer~\",\n            title: \"buffer~\",\n            children: \"buffer~\"\n          }), \" object to reference (instead of using the local name).\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"Setting the \", _jsx(_components.a, {\n            href: \"/reference/gen~\",\n            title: \"gen~\",\n            children: \"gen~\"\n          }), \" attribute corresponding to a named \", _jsx(_components.a, {\n            href: \"/reference/gen_dsp_data\",\n            title: \"gen_dsp_data\",\n            children: \"data\"\n          }), \" object copies in values from the corresponding MSP \", _jsx(_components.a, {\n            href: \"/reference/buffer~\",\n            title: \"buffer~\",\n            children: \"buffer~\"\n          }), \", while for a named \", _jsx(_components.a, {\n            href: \"/reference/gen_dsp_buffer\",\n            title: \"gen_dsp_buffer\",\n            children: \"buffer\"\n          }), \" object it changes the MSP \", _jsx(_components.a, {\n            href: \"/reference/buffer~\",\n            title: \"buffer~\",\n            children: \"buffer~\"\n          }), \" referenced. The \", _jsx(_components.a, {\n            href: \"/reference/gen_dsp_buffer\",\n            title: \"gen_dsp_buffer\",\n            children: \"buffer\"\n          }), \" object always has the size of the \", _jsx(_components.a, {\n            href: \"/reference/buffer~\",\n            title: \"buffer~\",\n            children: \"buffer~\"\n          }), \" object it references (which may change). The \", _jsx(_components.a, {\n            href: \"/reference/gen_dsp_data\",\n            title: \"gen_dsp_data\",\n            children: \"data\"\n          }), \" object has the size of its initial definition, or the size of the \", _jsx(_components.a, {\n            href: \"/reference/buffer~\",\n            title: \"buffer~\",\n            children: \"buffer~\"\n          }), \" object which was copied to it (whichever is smaller).\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"The \", _jsx(_components.a, {\n            href: \"/reference/gen_dsp_data\",\n            title: \"gen_dsp_data\",\n            children: \"data\"\n          }), \" object always uses 64-bit doubles, while the \", _jsx(_components.a, {\n            href: \"/reference/gen_dsp_buffer\",\n            title: \"gen_dsp_buffer\",\n            children: \"buffer\"\n          }), \" object converts from the bit resolution of the MSP \", _jsx(_components.a, {\n            href: \"/reference/buffer~\",\n            title: \"buffer~\",\n            children: \"buffer~\"\n          }), \" object (currently 32-bit floats) for all read and write operations, and may be less efficient.\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"eventrate-gen\",\n      children: \"Event-rate Gen\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.a, {\n        href: \"/reference/gen~\",\n        title: \"gen~\",\n        children: \"gen~\"\n      }), \" object also has an event-rate version, called \", _jsx(_components.a, {\n        href: \"/reference/gen\",\n        title: \"gen\",\n        children: \"gen\"\n      }), \". Internally, the event-rate \", _jsx(_components.a, {\n        href: \"/reference/gen\",\n        title: \"gen\",\n        children: \"gen\"\n      }), \" object supports all of the same operators as \", _jsx(_components.a, {\n        href: \"/reference/gen~\",\n        title: \"gen~\",\n        children: \"gen~\"\n      }), \". The only difference is that \", _jsx(_components.a, {\n        href: \"/reference/gen\",\n        title: \"gen\",\n        children: \"gen\"\n      }), \" is an event-rate object, and is not part of the audio graph. Like most event-rate objects, the first inlet to \", _jsx(_components.a, {\n        href: \"/reference/gen\",\n        title: \"gen\",\n        children: \"gen\"\n      }), \" is hot, and will trigger computation. However, you can also use the \", _jsx(_components.code, {\n        children: \"@interval\"\n      }), \" attribute in conjunction with the \", _jsx(_components.code, {\n        children: \"@active\"\n      }), \" attribute to enable an internal metronome, which will trigger computation at a consistent rate. When using the event-rate \", _jsx(_components.a, {\n        href: \"/reference/gen\",\n        title: \"gen\",\n        children: \"gen\"\n      }), \" object, the \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_samplerate\",\n        className: \"c74-object-link\",\n        children: \"samplerate\"\n      }), \" operator will return \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsx(_components.mrow, {\n                children: _jsxs(_components.mfrac, {\n                  children: [_jsx(_components.mn, {\n                    children: \"1000\"\n                  }), _jsxs(_components.mrow, {\n                    children: [_jsx(_components.mi, {\n                      mathvariant: \"normal\",\n                      children: \"@\"\n                    }), _jsx(_components.mi, {\n                      children: \"i\"\n                    }), _jsx(_components.mi, {\n                      children: \"n\"\n                    }), _jsx(_components.mi, {\n                      children: \"t\"\n                    }), _jsx(_components.mi, {\n                      children: \"e\"\n                    }), _jsx(_components.mi, {\n                      children: \"r\"\n                    }), _jsx(_components.mi, {\n                      children: \"v\"\n                    }), _jsx(_components.mi, {\n                      children: \"a\"\n                    }), _jsx(_components.mi, {\n                      children: \"l\"\n                    })]\n                  })]\n                })\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"\\\\frac{1000}{@interval}\"\n              })]\n            })\n          })\n        }), _jsx(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"1.1901em\",\n                verticalAlign: \"-0.345em\"\n              }\n            }), _jsxs(_components.span, {\n              className: \"mord\",\n              children: [_jsx(_components.span, {\n                className: \"mopen nulldelimiter\"\n              }), _jsx(_components.span, {\n                className: \"mfrac\",\n                children: _jsxs(_components.span, {\n                  className: \"vlist-t vlist-t2\",\n                  children: [_jsxs(_components.span, {\n                    className: \"vlist-r\",\n                    children: [_jsxs(_components.span, {\n                      className: \"vlist\",\n                      style: {\n                        height: \"0.8451em\"\n                      },\n                      children: [_jsxs(_components.span, {\n                        style: {\n                          top: \"-2.655em\"\n                        },\n                        children: [_jsx(_components.span, {\n                          className: \"pstrut\",\n                          style: {\n                            height: \"3em\"\n                          }\n                        }), _jsx(_components.span, {\n                          className: \"sizing reset-size6 size3 mtight\",\n                          children: _jsxs(_components.span, {\n                            className: \"mord mtight\",\n                            children: [_jsx(_components.span, {\n                              className: \"mord mtight\",\n                              children: \"@\"\n                            }), _jsx(_components.span, {\n                              className: \"mord mathnormal mtight\",\n                              children: \"in\"\n                            }), _jsx(_components.span, {\n                              className: \"mord mathnormal mtight\",\n                              children: \"t\"\n                            }), _jsx(_components.span, {\n                              className: \"mord mathnormal mtight\",\n                              style: {\n                                marginRight: \"0.02778em\"\n                              },\n                              children: \"er\"\n                            }), _jsx(_components.span, {\n                              className: \"mord mathnormal mtight\",\n                              style: {\n                                marginRight: \"0.03588em\"\n                              },\n                              children: \"v\"\n                            }), _jsx(_components.span, {\n                              className: \"mord mathnormal mtight\",\n                              children: \"a\"\n                            }), _jsx(_components.span, {\n                              className: \"mord mathnormal mtight\",\n                              style: {\n                                marginRight: \"0.01968em\"\n                              },\n                              children: \"l\"\n                            })]\n                          })\n                        })]\n                      }), _jsxs(_components.span, {\n                        style: {\n                          top: \"-3.23em\"\n                        },\n                        children: [_jsx(_components.span, {\n                          className: \"pstrut\",\n                          style: {\n                            height: \"3em\"\n                          }\n                        }), _jsx(_components.span, {\n                          className: \"frac-line\",\n                          style: {\n                            borderBottomWidth: \"0.04em\"\n                          }\n                        })]\n                      }), _jsxs(_components.span, {\n                        style: {\n                          top: \"-3.394em\"\n                        },\n                        children: [_jsx(_components.span, {\n                          className: \"pstrut\",\n                          style: {\n                            height: \"3em\"\n                          }\n                        }), _jsx(_components.span, {\n                          className: \"sizing reset-size6 size3 mtight\",\n                          children: _jsx(_components.span, {\n                            className: \"mord mtight\",\n                            children: _jsx(_components.span, {\n                              className: \"mord mtight\",\n                              children: \"1000\"\n                            })\n                          })\n                        })]\n                      })]\n                    }), _jsx(_components.span, {\n                      className: \"vlist-s\",\n                      children: \"​\"\n                    })]\n                  }), _jsx(_components.span, {\n                    className: \"vlist-r\",\n                    children: _jsx(_components.span, {\n                      className: \"vlist\",\n                      style: {\n                        height: \"0.345em\"\n                      },\n                      children: _jsx(_components.span, {})\n                    })\n                  })]\n                })\n              }), _jsx(_components.span, {\n                className: \"mclose nulldelimiter\"\n              })]\n            })]\n          })\n        })]\n      }), \", and the \", _jsx(_components.a, {\n        href: \"/reference/gen_dsp_vectorsize\",\n        className: \"c74-object-link\",\n        children: \"vectorsize\"\n      }), \" operator will always return 1.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"technical-notes\",\n      children: \"Technical notes\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"All operations in \", _jsx(_components.a, {\n        href: \"/reference/gen~\",\n        title: \"gen~\",\n        children: \"gen~\"\n      }), \" use 64-bit doubles.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The compilation process for \", _jsx(_components.a, {\n        href: \"/reference/gen~\",\n        title: \"gen~\",\n        children: \"gen~\"\n      }), \" Gen patchers and GenExprs includes an optimization that takes into account the update rate of each operator, so that any calculations that do not need to occur at sample rate (such as arithmetic on the outputs of param operators) instead process at a slower rate (determined by the host patcher vector size) for efficiency.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"jitter-gen-objects\",\n      children: \"Jitter Gen Objects\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"There are three Gen objects in Jitter: \", _jsx(_components.a, {\n        href: \"/reference/jit.gen\",\n        title: \"jit.gen\",\n        children: \"jit.gen\"\n      }), \", \", _jsx(_components.a, {\n        href: \"/reference/jit.pix\",\n        title: \"jit.pix\",\n        children: \"jit.pix\"\n      }), \", and \", _jsx(_components.a, {\n        href: \"/reference/jit.gl.pix\",\n        title: \"jit.gl.pix\",\n        children: \"jit.gl.pix\"\n      }), \". The \", _jsx(_components.a, {\n        href: \"/reference/jit.gen\",\n        title: \"jit.gen\",\n        children: \"jit.gen\"\n      }), \" and \", _jsx(_components.a, {\n        href: \"/reference/jit.pix\",\n        title: \"jit.pix\",\n        children: \"jit.pix\"\n      }), \" objects process Jitter matrices similar to \", _jsx(_components.a, {\n        href: \"/reference/jit.expr\",\n        title: \"jit.expr\",\n        children: \"jit.expr\"\n      }), \". The \", _jsx(_components.a, {\n        href: \"/reference/jit.gl.pix\",\n        title: \"jit.gl.pix\",\n        children: \"jit.gl.pix\"\n      }), \" object processes textures and matrices just like \", _jsx(_components.a, {\n        href: \"/reference/jit.gl.slab\",\n        title: \"jit.gl.slab\",\n        children: \"jit.gl.slab\"\n      }), \". The \", _jsx(_components.a, {\n        href: \"/reference/jit.gen\",\n        title: \"jit.gen\",\n        children: \"jit.gen\"\n      }), \" object is a generic matrix processing object that can handle matrices with any planecount, type and dimension. \", _jsx(_components.a, {\n        href: \"/reference/jit.pix\",\n        title: \"jit.pix\",\n        children: \"jit.pix\"\n      }), \" and \", _jsx(_components.a, {\n        href: \"/reference/jit.gl.pix\",\n        title: \"jit.gl.pix\",\n        children: \"jit.gl.pix\"\n      }), \", on the other hand, are specifically designed for working with pixel data. They can handle data of any type, but it must be two dimensional or less and have at most four planes.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"jitter-operators\",\n      children: \"Jitter Operators\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"coordinates\",\n      children: \"Coordinates\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Jitter Gen patchers describe the processing kernel for each cell in a matrix or texture. As the kernel is processing the input matrices, a set of coordinates is generated describing the location of the current cell being processed. The objects are just like the operators in \", _jsx(_components.a, {\n        href: \"/reference/jit.expr\",\n        title: \"jit.expr\",\n        children: \"jit.expr\"\n      }), \". They are \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_norm\",\n        title: \"gen_jit_norm\",\n        children: \"norm\"\n      }), \", \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_snorm\",\n        title: \"gen_jit_snorm\",\n        children: \"snorm\"\n      }), \", and \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_cell\",\n        title: \"gen_jit_cell\",\n        children: \"cell\"\n      }), \", with the \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_dim\",\n        title: \"gen_jit_dim\",\n        children: \"dim\"\n      }), \" operator giving the dimensions of the input matrix.\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"/reference/gen_jit_norm\",\n          title: \"gen_jit_norm\",\n          children: \"norm\"\n        }), \" ranges from \", _jsx(_components.code, {\n          children: \"[0, 1]\"\n        }), \" across all matrix dimensions and is defined as \", _jsx(_components.em, {\n          children: \"norm = cell/dim\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"/reference/gen_jit_snorm\",\n          title: \"gen_jit_snorm\",\n          children: \"snorm\"\n        }), \" ranges from \", _jsx(_components.code, {\n          children: \"[-1, 1]\"\n        }), \" across all matrix dimensions and is defined as \", _jsx(_components.em, {\n          children: \"snorm = cell/dim*2-1\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"/reference/gen_jit_cell\",\n          title: \"gen_jit_cell\",\n          children: \"cell\"\n        }), \" gives the current cell index.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"vectors\",\n      children: \"Vectors\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Since Jitter matrices represent arrays of vector (more than one plane) data, all Gen operators in Jitter can process vectors of any size, so Gen patchers once created work equally on any vector size. The basic binary operators \", _jsx(_components.code, {\n        children: \"+\"\n      }), \", \", _jsx(_components.code, {\n        children: \"-\"\n      }), \", \", _jsx(_components.code, {\n        children: \"*\"\n      }), \", \", _jsx(_components.code, {\n        children: \"/\"\n      }), \", and \", _jsx(_components.code, {\n        children: \"%\"\n      }), \" can take vector arguments as in \", _jsx(_components.code, {\n        children: \"[+ 0.5 0.25 0.15]\"\n      }), \", which will create an addition operator adding a vector with the three components to its input.  Also, the \", _jsx(_components.a, {\n        href: \"/reference/gen_common_param\",\n        title: \"gen_common_param\",\n        children: \"param\"\n      }), \" operator can take vector default values as in \", _jsx(_components.code, {\n        children: \"[param 1 2 3 4]\"\n      }), \".  Parameters can have up to 32 values in \", _jsx(_components.a, {\n        href: \"/reference/jit.gen\",\n        title: \"jit.gen\",\n        children: \"jit.gen\"\n      }), \" and 4 values in \", _jsx(_components.a, {\n        href: \"/reference/jit.pix\",\n        title: \"jit.pix\",\n        children: \"jit.pix\"\n      }), \" and \", _jsx(_components.a, {\n        href: \"/reference/jit.gl.pix\",\n        title: \"jit.gl.pix\",\n        children: \"jit.gl.pix\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_vec\",\n        title: \"gen_jit_vec\",\n        children: \"vec\"\n      }), \" operator creates vector constants and packs values together in a vector. It takes default arguments for its components and casts all of its inputs to scalar values before packing them together.\"]\n    }), \"\\n\", _jsxs(_components.figure, {\n      \"data-variant\": \"patcher\",\n      \"data-patch-id\": \"patch-8a366637-c697-4d61-887f-cdb9f814fabd\",\n      children: [_jsx(_components.p, {\n        children: _jsx(_components.img, {\n          alt: \"\",\n          height: \"199\",\n          src: \"../../userguide/images/cb8fd477ccec2aa34a95ee9cd14a9182_922.webp\",\n          srcSet: \"../../userguide/images/cb8fd477ccec2aa34a95ee9cd14a9182_922.webp 2x\",\n          title: \"gen_019\",\n          width: \"461\"\n        })\n      }), _jsx(_components.figcaption, {\n        children: \"You can use the vec operator as an object or in a codebox\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"swiz\"\n      }), \" operator applies a swizzle operation to vectors. In GLSL and similar shading languages, vector components can be accessed by indexing the vector with named planes. For example in GLSL you might see\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [\"red \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" color.r\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"or\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [\"redalpha \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" color.ra\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"or even\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [\"val \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" color.rbbg\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.figure, {\n      \"data-variant\": \"patcher\",\n      \"data-patch-id\": \"patch-6bcc27e4-14b9-485d-857e-756fe0b183b8\",\n      children: [_jsx(_components.p, {\n        children: _jsx(_components.img, {\n          alt: \"\",\n          height: \"193\",\n          src: \"../../userguide/images/ce2b206ab007d8da7a289a915de85d90_950.webp\",\n          srcSet: \"../../userguide/images/ce2b206ab007d8da7a289a915de85d90_950.webp 2x\",\n          title: \"gen_020\",\n          width: \"475\"\n        })\n      }), _jsx(_components.figcaption, {\n        children: \"Use the swiz operator as an object to pick certain planes. In a codebox, do swizzling with a dot operator.\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This type of operation is referred to as \", _jsx(_components.em, {\n        children: \"swizzling\"\n      }), \". The \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_swiz\",\n        title: \"gen_jit_swiz\",\n        children: \"swiz\"\n      }), \" operator can take named arguments using the letters \", _jsx(_components.code, {\n        children: \"r\"\n      }), \", \", _jsx(_components.code, {\n        children: \"g\"\n      }), \", \", _jsx(_components.code, {\n        children: \"b\"\n      }), \", \", _jsx(_components.code, {\n        children: \"a\"\n      }), \", as well as \", _jsx(_components.code, {\n        children: \"x\"\n      }), \", \", _jsx(_components.code, {\n        children: \"y\"\n      }), \", \", _jsx(_components.code, {\n        children: \"z\"\n      }), \", \", _jsx(_components.code, {\n        children: \"w\"\n      }), \" in addition to numeric indices starting at \", _jsx(_components.code, {\n        children: \"0\"\n      }), \". The letters are convenient for vectors with four or less planes, but for larger vectors numeric indices must be used. The compilation process automatically checks any swiz operation so arguments indexing components larger than the vector being processed will be clamped to the size of the vector.\"]\n    }), \"\\n\", _jsxs(_components.figure, {\n      \"data-variant\": \"patcher\",\n      \"data-patch-id\": \"patch-491c516f-9461-4127-879b-3ee1a027b2fb\",\n      children: [_jsx(_components.p, {\n        children: _jsx(_components.img, {\n          alt: \"\",\n          height: \"271\",\n          src: \"../../userguide/images/c5e354b101eb273abb822374a7bc3374_560.webp\",\n          srcSet: \"../../userguide/images/c5e354b101eb273abb822374a7bc3374_560.webp 2x\",\n          title: \"gen_021\",\n          width: \"280\"\n        })\n      }), _jsx(_components.figcaption, {\n        children: \"Out of bounds swiz operations will be clamped\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In addition, there are the basic vector operations for spatial calculations. These are \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_length\",\n        title: \"gen_jit_length\",\n        children: \"length\"\n      }), \", \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_normalize\",\n        title: \"gen_jit_normalize\",\n        children: \"normalize\"\n      }), \", \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_cross\",\n        title: \"gen_jit_cross\",\n        children: \"cross\"\n      }), \", \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_dot\",\n        title: \"gen_jit_dot\",\n        children: \"dot\"\n      }), \", and \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_reflect\",\n        title: \"gen_jit_reflect\",\n        children: \"reflect\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"sampling\",\n      children: \"Sampling\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Sampling operators are one of the most powerful features of Jitter Gen patchers. Sampling operators take an input and a coordinate in the range \", _jsx(_components.code, {\n        children: \"[0, 1]\"\n      }), \" as an argument, returning the data at the coordinate’s position in the matrix or texture. The first argument always has to be a Gen patcher input while the second argument is an N-dimensional vector whose size is equal to the dimensionality of the input it is processing. If the coordinate argument is outside of the range \", _jsx(_components.code, {\n        children: \"[0, 1]\"\n      }), \", it will be converted to a value within the range \", _jsx(_components.code, {\n        children: \"[0, 1]\"\n      }), \" according to its boundmode function. Possible boundmodes are \", _jsx(_components.code, {\n        children: \"wrap\"\n      }), \", \", _jsx(_components.code, {\n        children: \"mirror\"\n      }), \", and \", _jsx(_components.code, {\n        children: \"clamp\"\n      }), \", where \", _jsx(_components.code, {\n        children: \"wrap\"\n      }), \" is the default.\"]\n    }), \"\\n\", _jsxs(_components.figure, {\n      \"data-variant\": \"patcher\",\n      \"data-patch-id\": \"patch-eb71e1a6-9130-4224-9410-cbd12d48ff42\",\n      children: [_jsx(_components.p, {\n        children: _jsx(_components.img, {\n          alt: \"\",\n          height: \"209\",\n          src: \"../../userguide/images/c8bd0a4f0221ca5358f68c0a2e4537e8_1248.webp\",\n          srcSet: \"../../userguide/images/c8bd0a4f0221ca5358f68c0a2e4537e8_1248.webp 2x\",\n          title: \"gen_022\",\n          width: \"624\"\n        })\n      }), _jsx(_components.figcaption, {\n        children: \"You can use the sample operator as an object or in codebox.\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The two sampling operators in Jitter Gen patchers are \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_sample\",\n        title: \"gen_jit_sample\",\n        children: \"sample\"\n      }), \" and \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_nearest\",\n        title: \"gen_jit_nearest\",\n        children: \"nearest\"\n      }), \". The \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_sample\",\n        title: \"gen_jit_sample\",\n        children: \"sample\"\n      }), \" operator samples values form a matrix using N-dimensional linear interpolation. The \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_nearest\",\n        title: \"gen_jit_nearest\",\n        children: \"nearest\"\n      }), \" operator will simply grab the value from the closest cell.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"geometry\",\n      children: \"Geometry\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Jitter Gen patchers include a suite of objects for generating surfaces. These include most of the shapes available in the \", _jsx(_components.a, {\n        href: \"/reference/jit.gl.gridshape\",\n        title: \"jit.gl.gridshape\",\n        children: \"jit.gl.gridshape\"\n      }), \" object. Each surface function returns two values: the vertex position and the vertex normal. The geometry operators are \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_sphere\",\n        title: \"gen_jit_sphere\",\n        children: \"sphere\"\n      }), \", \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_torus\",\n        title: \"gen_jit_torus\",\n        children: \"torus\"\n      }), \", \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_circle\",\n        title: \"gen_jit_circle\",\n        children: \"circle\"\n      }), \", \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_plane\",\n        title: \"gen_jit_plane\",\n        children: \"plane\"\n      }), \", \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_cone\",\n        title: \"gen_jit_cone\",\n        children: \"cone\"\n      }), \", and \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_cylinder\",\n        title: \"gen_jit_cylinder\",\n        children: \"cylinder\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"color\",\n      children: \"Color\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"There are two color operators in Jitter Gen patchers. They are \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_rgb2hsl\",\n        title: \"gen_jit_rgb2hsl\",\n        children: \"rgb2hsl\"\n      }), \" and \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_hsl2rgb\",\n        title: \"gen_jit_hsl2rgb\",\n        children: \"hsl2rgb\"\n      }), \". These convert between the Red Green Blue color space and the Hue Saturation Luminance color space. If the input to these objects has an alpha component, the alpha will be passed through untouched.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"jit_gen\",\n      children: \"jit.gen\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.a, {\n        href: \"/reference/jit.gen\",\n        title: \"jit.gen\",\n        children: \"jit.gen\"\n      }), \" object is a general purpose matrix processing object. It compiles Gen patchers into native machine code representing the kernel of an N-dimensional matrix processing routine. It follows the Jitter matrix planemapping conventions for pixel data with planes [0-4] as the ARGB channels.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.a, {\n        href: \"/reference/jit.gen\",\n        title: \"jit.gen\",\n        children: \"jit.gen\"\n      }), \" can have any number of inlets and outlets, but the matrix format for the different inputs and outputs is always linked. In other words, the matrix format (planecount, type, dimensions) of the first inlet determines the matrix format for all other inputs and outputs. \", _jsx(_components.a, {\n        href: \"/reference/jit.gen\",\n        title: \"jit.gen\",\n        children: \"jit.gen\"\n      }), \" makes use of parallel processing just like other parallel aware objects in Jitter for maximum performance with large matrices.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"How a matrix is processed by \", _jsx(_components.a, {\n        href: \"/reference/jit.gen\",\n        title: \"jit.gen\",\n        children: \"jit.gen\"\n      }), \" is dependent on the input planecount, type, and dimension of the input matrices. In addition, there is a \", _jsx(_components.code, {\n        children: \"@precision\"\n      }), \" attribute that sets the type of the processing kernel. The default value for precision is \", _jsx(_components.code, {\n        children: \"auto\"\n      }), \". Auto precision automatically adapts the type of the kernel dependent upon the matrix input type. In \", _jsx(_components.code, {\n        children: \"auto\"\n      }), \" mode, the following mapping between input matrix type and kernel processing type is used:\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"char\"\n          }), \" maps to fixed\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"long\"\n          }), \" maps to float64\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"float32\"\n          }), \" maps to float32\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"float64\"\n          }), \" maps to float64\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Other possible values for the precision attribute are \", _jsx(_components.code, {\n        children: \"fixed\"\n      }), \", \", _jsx(_components.code, {\n        children: \"float32\"\n      }), \", and \", _jsx(_components.code, {\n        children: \"float64\"\n      }), \". Fixed precision is the only setting that doesn’t correspond to a Jitter matrix type. Fixed precision specifies a kernel type that performs a type of floating point calculation with integers using a technique called fixed-point arithmetic. It’s very fast and provides more precision than 8-bit char operations without incurring the cost of converting to a true floating-point type. However, fixed-point arithmetic calculations have more error that can sometimes be visible when using the sampling operators. If there are noticeable artifacts, simply increase the internal precision to \", _jsx(_components.code, {\n        children: \"float32\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"jit_pix\",\n      children: \"jit.pix\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.a, {\n        href: \"/reference/jit.pix\",\n        title: \"jit.pix\",\n        children: \"jit.pix\"\n      }), \" object is a matrix processing object specifically for pixel data. When processing matrices representing video and images, \", _jsx(_components.a, {\n        href: \"/reference/jit.pix\",\n        title: \"jit.pix\",\n        children: \"jit.pix\"\n      }), \" is the best object. Internally, data is in RGBA format always. If the input has less than four planes, \", _jsx(_components.a, {\n        href: \"/reference/jit.pix\",\n        title: \"jit.pix\",\n        children: \"jit.pix\"\n      }), \" will convert it to RGBA format according to the following rules:\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"1-plane, Luminance format, L to LLL1 (Luminance for RGB and 1 for Alpha)\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"2-plane Lumalpha format, LA to LLLA (Luminance for RGB and Alpha for Alpha)\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"3-plane RGB format, RGB to RGB1 (RGB for RGB and 1 for Alpha)\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"4-plane, ARGB format, ARGB to RGBA (changes the order of the channels internally)\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The output of \", _jsx(_components.a, {\n        href: \"/reference/jit.pix\",\n        title: \"jit.pix\",\n        children: \"jit.pix\"\n      }), \" is always a 4-plane matrix in ARGB format, which is the standard Jitter pixel planemapping. Like \", _jsx(_components.a, {\n        href: \"/reference/jit.gen\",\n        title: \"jit.gen\",\n        children: \"jit.gen\"\n      }), \", \", _jsx(_components.a, {\n        href: \"/reference/jit.pix\",\n        title: \"jit.pix\",\n        children: \"jit.pix\"\n      }), \" compiles Gen patchers into C++ and makes use of Jitter’s parallel processing system. \", _jsx(_components.a, {\n        href: \"/reference/jit.pix\",\n        title: \"jit.pix\",\n        children: \"jit.pix\"\n      }), \" also has a precision attribute that operates exactly the same was as it does in \", _jsx(_components.a, {\n        href: \"/reference/jit.gen\",\n        title: \"jit.gen\",\n        children: \"jit.gen\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"jit_gl_pix\",\n      children: \"jit.gl.pix\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.a, {\n        href: \"/reference/jit.gl.pix\",\n        title: \"jit.gl.pix\",\n        children: \"jit.gl.pix\"\n      }), \" object is a matrix and texture processing object specifically for pixel data that operates just like \", _jsx(_components.a, {\n        href: \"/reference/jit.gl.slab\",\n        title: \"jit.gl.slab\",\n        children: \"jit.gl.slab\"\n      }), \". The only difference between the two is that \", _jsx(_components.a, {\n        href: \"/reference/jit.gl.pix\",\n        title: \"jit.gl.pix\",\n        children: \"jit.gl.pix\"\n      }), \" compiles its patcher into GLSL while \", _jsx(_components.a, {\n        href: \"/reference/jit.gl.slab\",\n        title: \"jit.gl.slab\",\n        children: \"jit.gl.slab\"\n      }), \" reads it from a shader file. Like \", _jsx(_components.a, {\n        href: \"/reference/jit.pix\",\n        title: \"jit.pix\",\n        children: \"jit.pix\"\n      }), \", \", _jsx(_components.a, {\n        href: \"/reference/jit.gl.pix\",\n        title: \"jit.gl.pix\",\n        children: \"jit.gl.pix\"\n      }), \" uses an internal RGBA pixel format.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"technical-notes-jitter-gen\",\n      children: \"Technical notes (Jitter Gen)\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"numerical-values-in-the-kernel\",\n      children: _jsx(_components.strong, {\n        children: \"Numerical Values in the Kernel\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"All numerical values in Jitter Gen patches are conceptually floating point values.  This is the case even for fixed precision kernels.  It is particularly important to remember this when dealing with char matrices.  All char matrices are converted to the range \", _jsx(_components.code, {\n        children: \"[0, 1]\"\n      }), \" internally.  On output, this range is mapped back out to \", _jsx(_components.code, {\n        children: \"[0, 255]\"\n      }), \" in the char type.  A char value of 1 is equivalent to the floating point value of \", _jsxs(_components.span, {\n        className: \"katex\",\n        children: [_jsx(_components.span, {\n          className: \"katex-mathml\",\n          children: _jsx(_components.math, {\n            xmlns: \"http://www.w3.org/1998/Math/MathML\",\n            children: _jsxs(_components.semantics, {\n              children: [_jsxs(_components.mrow, {\n                children: [_jsx(_components.mn, {\n                  children: \"1\"\n                }), _jsx(_components.mi, {\n                  mathvariant: \"normal\",\n                  children: \"/\"\n                }), _jsx(_components.mn, {\n                  children: \"255\"\n                })]\n              }), _jsx(_components.annotation, {\n                encoding: \"application/x-tex\",\n                children: \"1/255\"\n              })]\n            })\n          })\n        }), _jsx(_components.span, {\n          className: \"katex-html\",\n          \"aria-hidden\": \"true\",\n          children: _jsxs(_components.span, {\n            className: \"base\",\n            children: [_jsx(_components.span, {\n              className: \"strut\",\n              style: {\n                height: \"1em\",\n                verticalAlign: \"-0.25em\"\n              }\n            }), _jsx(_components.span, {\n              className: \"mord\",\n              children: \"1/255\"\n            })]\n          })\n        })]\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"When using the comparison operators (\", _jsx(_components.code, {\n        children: \"==\"\n      }), \", \", _jsx(_components.code, {\n        children: \"!=\"\n      }), \", \", _jsx(_components.code, {\n        children: \"<\"\n      }), \", \", _jsx(_components.code, {\n        children: \"<=\"\n      }), \", \", _jsx(_components.code, {\n        children: \">\"\n      }), \", \", _jsx(_components.code, {\n        children: \">=\"\n      }), \"), it's particularly important to keep in mind the floating point nature of Gen patcher internal values because of their inherent imprecision.  Instead of directly testing for equality for example , it's more effective to test for whther a value falls within a certain small range (epsilon).  In the example below, the \", _jsx(_components.code, {\n        children: \"absdiff\"\n      }), \" operator calculates how far a value is from 1/255 and then the \", _jsx(_components.code, {\n        children: \"<\"\n      }), \" op tests to see if it's within the threshold of error.\"]\n    }), \"\\n\", _jsxs(_components.figure, {\n      \"data-variant\": \"patcher\",\n      \"data-patch-id\": \"patch-422b7df5-4eb4-4e94-affb-e267f84422d6\",\n      children: [_jsx(_components.p, {\n        children: _jsx(_components.img, {\n          alt: \"\",\n          height: \"273\",\n          src: \"../../userguide/images/2f8a081fdb9d8e1a54abbe23f9b593cc_774.webp\",\n          srcSet: \"../../userguide/images/2f8a081fdb9d8e1a54abbe23f9b593cc_774.webp 2x\",\n          title: \"gen_023\",\n          width: \"387\"\n        })\n      }), _jsx(_components.figcaption, {\n        children: \"Rather than testing for equivalence, test whether values are within some epsilon distance of a target value.\"\n      })]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"jit_pix-vs_-jit_gl_pix\",\n      children: \"jit.pix vs. jit.gl.pix\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For the most part \", _jsx(_components.a, {\n        href: \"/reference/jit.pix\",\n        title: \"jit.pix\",\n        children: \"jit.pix\"\n      }), \" and \", _jsx(_components.a, {\n        href: \"/reference/jit.gl.pix\",\n        title: \"jit.gl.pix\",\n        children: \"jit.gl.pix\"\n      }), \" will behave identically despite one being CPU-oriented and the other GPU-oriented. The differences have to do with differences in behavior between how matrix inputs are handled with \", _jsx(_components.a, {\n        href: \"/reference/jit.pix\",\n        title: \"jit.pix\",\n        children: \"jit.pix\"\n      }), \" and how texture inputs are handled with \", _jsx(_components.a, {\n        href: \"/reference/jit.gl.pix\",\n        title: \"jit.gl.pix\",\n        children: \"jit.gl.pix\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"All of the inputs to \", _jsx(_components.a, {\n        href: \"/reference/jit.pix\",\n        title: \"jit.pix\",\n        children: \"jit.pix\"\n      }), \" will adapt in size, type, and dimension to the left-most input. As a result, all input matrices within a \", _jsx(_components.a, {\n        href: \"/reference/jit.pix\",\n        title: \"jit.pix\",\n        children: \"jit.pix\"\n      }), \" processing kernel will have the same values for the cell and dim operators. In \", _jsx(_components.a, {\n        href: \"/reference/jit.gl.pix\",\n        title: \"jit.gl.pix\",\n        children: \"jit.gl.pix\"\n      }), \", inputs can have different sizes. In \", _jsx(_components.a, {\n        href: \"/reference/jit.gl.pix\",\n        title: \"jit.gl.pix\",\n        children: \"jit.gl.pix\"\n      }), \", the values for the cell and dim operators are calculated from the properties of the left-most input (\", _jsx(_components.em, {\n        children: \"in1\"\n      }), \"). A future version may include per-input cell and dim operators, but for now this is not the case.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Since the sampling operators take normalized coordinates in the range \", _jsx(_components.code, {\n        children: \"[0, 1]\"\n      }), \", differently sized input textures will still be properly sampled using the norm operator since its value is independent of varying input sizes. However, in \", _jsx(_components.a, {\n        href: \"/reference/jit.gl.pix\",\n        title: \"jit.gl.pix\",\n        children: \"jit.gl.pix\"\n      }), \" the \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_sample\",\n        title: \"gen_jit_sample\",\n        children: \"sample\"\n      }), \" and \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_nearest\",\n        title: \"gen_jit_nearest\",\n        children: \"nearest\"\n      }), \" operators behave differently than with \", _jsx(_components.a, {\n        href: \"/reference/jit.pix\",\n        title: \"jit.pix\",\n        children: \"jit.pix\"\n      }), \". How a texture is sampled is determined by the properties of the texture. As a consequence, sample and nearest behave the same in \", _jsx(_components.a, {\n        href: \"/reference/jit.gl.pix\",\n        title: \"jit.gl.pix\",\n        children: \"jit.gl.pix\"\n      }), \". To enable nearest sampling, set the \", _jsx(_components.code, {\n        children: \"@filter\"\n      }), \" attribute to nearest. For linear interpolation, set \", _jsx(_components.code, {\n        children: \"@filter\"\n      }), \" to linear (the default).\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"see-also\",\n      children: \"See Also\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"../mc/mc_gen.md\",\n          children: \"mc_gen\"\n        })\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","tags":[],"kind":"","contributors":[],"publishDate":"2024-10-30T12:00:00.000Z","categories":[],"files":[],"articles":[]}