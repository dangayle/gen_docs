{"title":"GenExpr","description":"Documentation for GenExpr, the expression language used by Gen and inside of Gen codebox","headings":[{"depth":1,"id":"genexpr","text":"GenExpr"},{"depth":2,"id":"the-gen-patcher-and-the-codebox-object","text":"The Gen Patcher and the codebox Object"},{"depth":2,"id":"language-basics","text":"Language Basics"},{"depth":2,"id":"parameters","text":"Parameters"},{"depth":2,"id":"comments","text":"Comments"},{"depth":2,"id":"multiple-return-values","text":"Multiple Return Values"},{"depth":2,"id":"defining-genexpr-functions","text":"Defining GenExpr Functions"},{"depth":2,"id":"operator-attributes","text":"Operator Attributes"},{"depth":3,"id":"attributes-in-function-definitions","text":"Attributes in Function Definitions"},{"depth":2,"id":"abstractions-as-genexpr-functions","text":"Abstractions as GenExpr Functions"},{"depth":2,"id":"requiring-genexpr-files","text":"Requiring GenExpr Files"},{"depth":2,"id":"branching-and-looping","text":"Branching and Looping"},{"depth":3,"id":"continue-and-break","text":"Continue and Break"},{"depth":2,"id":"genexpr-and-jitter-inputs","text":"GenExpr and Jitter Inputs"},{"depth":2,"id":"genexpr-and-jitter-coordinate-operations","text":"GenExpr and Jitter Coordinate Operations"},{"depth":2,"id":"technical-notes","text":"Technical Notes"}],"patchers":[],"content":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    code: \"code\",\n    em: \"em\",\n    figure: \"figure\",\n    h1: \"h1\",\n    h2: \"h2\",\n    h3: \"h3\",\n    img: \"img\",\n    p: \"p\",\n    pre: \"pre\",\n    span: \"span\",\n    strong: \"strong\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      id: \"genexpr\",\n      children: \"GenExpr\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"GenExpr is the internal language used by Gen patchers. It is used to describe computations in an implementation agnostic manner. To perform actual computations, it is translated into machine code for the CPU or GPU by the various Gen objects ( \", _jsx(_components.a, {\n        href: \"/reference/gen\",\n        title: \"gen\",\n        children: \"gen\"\n      }), \", \", _jsx(_components.a, {\n        href: \"/reference/gen~\",\n        title: \"gen~\",\n        children: \"gen~\"\n      }), \", \", _jsx(_components.a, {\n        href: \"/reference/jit.gen\",\n        title: \"jit.gen\",\n        children: \"jit.gen\"\n      }), \", etc.).\\nThe GenExpr language can be used directly in Gen patchers with the \", _jsx(_components.a, {\n        href: \"/reference/gen_common_expr\",\n        title: \"gen_common_expr\",\n        children: \"expr\"\n      }), \" and \", _jsx(_components.a, {\n        href: \"/reference/gen_common_codebox\",\n        title: \"gen_common_codebox\",\n        children: \"codebox\"\n      }), \" objects. These objects analyze the expressions written in them and automatically construct the the appropriate number of inlets and outlets so that patchcords can be connected to the computations described within.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Note that there is absolutely no difference in terms of performance between describing computations with object boxes and the GenExpr language. When a Gen patcher is compiled, it all gets merged into a single representation, so use the approach that is most convenient for the problem.\"\n    }), \"\\n\", _jsx(_components.p, {}), _jsxs(_components.figure, {\n      \"data-variant\": \"image\",\n      children: [\"\\n\", _jsx(_components.img, {\n        alt: \"\",\n        height: \"246\",\n        src: \"../../userguide/images/e9665a3edd0fc6da53b7fda5d347be0e_500.webp\",\n        srcSet: \"../../userguide/images/e9665a3edd0fc6da53b7fda5d347be0e_500.webp 2x\",\n        title: \"genexpr_001\",\n        width: \"250\"\n      }), \"\\n\\n\"]\n    }), _jsx(_components.p, {}), \"\\n\", _jsx(_components.h2, {\n      id: \"the-gen-patcher-and-the-codebox-object\",\n      children: \"The Gen Patcher and the codebox Object\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The GenExpr language is designed to complement the Max patching environment within Gen patchers. It provides a parallel textual mechanism for describing computations to be used in concert with the graphical patching paradigm of Max. As one example, the structural elements of user-defined GenExpr functions correspond closely to the structural elements of Max objects with their notions of inlets, outlets, arguments and attributes. Furthermore, the GenExpr language has keywords \", _jsx(_components.code, {\n        children: \"in\"\n      }), \", \", _jsx(_components.code, {\n        children: \"in1\"\n      }), \", \", _jsx(_components.code, {\n        children: \"in2\"\n      }), \", … and \", _jsx(_components.code, {\n        children: \"out\"\n      }), \", \", _jsx(_components.code, {\n        children: \"out1\"\n      }), \", \", _jsx(_components.code, {\n        children: \"out2\"\n      }), \", … that specifically refer to the inlets and outlets of the \", _jsx(_components.a, {\n        href: \"/reference/gen_common_expr\",\n        title: \"gen_common_expr\",\n        children: \"expr\"\n      }), \" or \", _jsx(_components.a, {\n        href: \"/reference/gen_common_codebox\",\n        title: \"gen_common_codebox\",\n        children: \"codebox\"\n      }), \" the GenExpr code is embedded in.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"language-basics\",\n      children: \"Language Basics\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The GenExpr language resembles C and JavaScript for simple expression statements; however, semicolons are only necessary when there are multiple statements. The codeboxes below all contain valid expressions in GenExpr. When there is a single expression with no assignment like in the far left codebox, the assignment to out1 is implied. Notice that it also doesn’t have a semicolon at the end. When there is only one statement, the semicolon is also implied.\"\n    }), \"\\n\", _jsx(_components.p, {}), _jsxs(_components.figure, {\n      \"data-variant\": \"image\",\n      children: [\"\\n\", _jsx(_components.img, {\n        alt: \"\",\n        height: \"202\",\n        src: \"../../userguide/images/e152866176e7fbda11e922ba14413016_1290.webp\",\n        srcSet: \"../../userguide/images/e152866176e7fbda11e922ba14413016_1290.webp 2x\",\n        title: \"genexpr_002\",\n        width: \"645\"\n      }), \"\\n\\n\"]\n    }), _jsx(_components.p, {}), \"\\n\", _jsxs(_components.p, {\n      children: [\"For multi-line statements however, semicolons are required. The \", _jsx(_components.a, {\n        href: \"/reference/codebox\",\n        title: \"codebox\",\n        children: \"codebox\"\n      }), \" on the left doesn’t have them and will generate errors. The codebox on the right is correct.\"]\n    }), \"\\n\", _jsx(_components.p, {}), _jsxs(_components.figure, {\n      \"data-variant\": \"image\",\n      children: [\"\\n\", _jsx(_components.img, {\n        alt: \"\",\n        height: \"251\",\n        src: \"../../userguide/images/252d59286f6181ab03ffed7b05e68fc7_1332.webp\",\n        srcSet: \"../../userguide/images/252d59286f6181ab03ffed7b05e68fc7_1332.webp 2x\",\n        title: \"genexpr_003\",\n        width: \"666\"\n      }), \"\\n\\n\"]\n    }), _jsx(_components.p, {}), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.a, {\n        href: \"/reference/gen_common_expr\",\n        title: \"gen_common_expr\",\n        children: \"expr\"\n      }), \" operator is functionally the same as a \", _jsx(_components.a, {\n        href: \"/reference/gen_common_codebox\",\n        title: \"gen_common_codebox\",\n        children: \"codebox\"\n      }), \" but lacks the text editor features such as syntax highlighting and multi-line text display and navigation. \", _jsx(_components.a, {\n        href: \"/reference/gen_common_expr\",\n        title: \"gen_common_expr\",\n        children: \"expr\"\n      }), \" is most useful for short, one-line expressions, saving the effort of patching together a sequence of objects together that operate as a unit.\"]\n    }), \"\\n\", _jsx(_components.p, {}), _jsxs(_components.figure, {\n      \"data-variant\": \"image\",\n      children: [\"\\n\", _jsx(_components.img, {\n        alt: \"\",\n        height: \"200\",\n        src: \"../../userguide/images/a5451892fc937c3bf12bedccfb059eac_904.webp\",\n        srcSet: \"../../userguide/images/a5451892fc937c3bf12bedccfb059eac_904.webp 2x\",\n        title: \"genexpr_004\",\n        width: \"452\"\n      }), \"\\n\\n\"]\n    }), _jsx(_components.p, {}), \"\\n\", _jsxs(_components.p, {\n      children: [\"An \", _jsx(_components.a, {\n        href: \"/reference/gen_common_expr\",\n        title: \"gen_common_expr\",\n        children: \"expr\"\n      }), \" or \", _jsx(_components.a, {\n        href: \"/reference/gen_common_codebox\",\n        title: \"gen_common_codebox\",\n        children: \"codebox\"\n      }), \" determines its number of inlets and outlets by detecting the \", _jsx(_components.code, {\n        children: \"inN\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"outN\"\n      }), \" keywords where \", _jsx(_components.code, {\n        children: \"N\"\n      }), \" is the inlet/outlet position. \", _jsx(_components.code, {\n        children: \"in1\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"out1\"\n      }), \" are the left-most inlet and outlet respectively. For convenience, the keywords \", _jsx(_components.code, {\n        children: \"in\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"out\"\n      }), \" are equivalent to \", _jsx(_components.code, {\n        children: \"in1\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"out1\"\n      }), \" respectively.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Almost every object that can be created in a Gen patcher is also available from within GenExpr as either a function, a global variable, a declaration, or a constant. The number of inlets an object has corresponds to the number of arguments a function takes. For example, the object \", _jsx(_components.a, {\n        href: \"/reference/gen_common_atan2\",\n        title: \"gen_common_atan2\",\n        children: \"atan2\"\n      }), \" has two inlets and takes two arguments as follows:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"out\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" atan2( \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in1\"\n        }), \" ,  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in2\"\n        }), \" )\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"parameters\",\n      children: \"Parameters\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Parameters declared in GenExpr behave just like \", _jsx(_components.a, {\n        href: \"/reference/gen_common_param\",\n        title: \"gen_common_param\",\n        children: \"param\"\n      }), \" operators in a patch.  They can only be declared in the main body of GenExpr code where inlets and outlets (\", _jsx(_components.em, {\n        children: \"inN\"\n      }), \" and \", _jsx(_components.em, {\n        children: \"outN\"\n      }), \") exist because they operate at the same level as object box Gen operators in the patcher.\"]\n    }), \"\\n\", _jsx(_components.p, {}), _jsxs(_components.figure, {\n      \"data-variant\": \"image\",\n      children: [\"\\n\", _jsx(_components.img, {\n        alt: \"\",\n        height: \"257\",\n        src: \"../../userguide/images/a93529d1e4e9cc69b25431bb9122f595_680.webp\",\n        srcSet: \"../../userguide/images/a93529d1e4e9cc69b25431bb9122f595_680.webp 2x\",\n        title: \"genexpr_005\",\n        width: \"340\"\n      }), \"\\n\\n\"]\n    }), _jsx(_components.p, {}), \"\\n\", _jsxs(_components.p, {\n      children: [\"A \", _jsx(_components.a, {\n        href: \"/reference/gen_common_param\",\n        title: \"gen_common_param\",\n        children: \"param\"\n      }), \" declaration in GenExpr names a parameter and creates it if necessary.  If there is a \", _jsx(_components.a, {\n        href: \"/reference/gen_common_param\",\n        title: \"gen_common_param\",\n        children: \"param\"\n      }), \" object box with the same name as a \", _jsx(_components.a, {\n        href: \"/reference/gen_common_param\",\n        title: \"gen_common_param\",\n        children: \"param\"\n      }), \" declared in GenExpr, the GenExpr \", _jsx(_components.a, {\n        href: \"/reference/gen_common_param\",\n        title: \"gen_common_param\",\n        children: \"param\"\n      }), \" will simply alias the object box \", _jsx(_components.a, {\n        href: \"/reference/gen_common_param\",\n        title: \"gen_common_param\",\n        children: \"param\"\n      }), \".  If there isn't a \", _jsx(_components.a, {\n        href: \"/reference/gen_common_param\",\n        title: \"gen_common_param\",\n        children: \"param\"\n      }), \" object box with the same name, one will be implicitly created.  In the code above, offset aliases the object box \", _jsx(_components.a, {\n        href: \"/reference/gen_common_param\",\n        title: \"gen_common_param\",\n        children: \"param\"\n      }), \" offset, while amp creates a new global \", _jsx(_components.a, {\n        href: \"/reference/gen_common_param\",\n        title: \"gen_common_param\",\n        children: \"param\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"comments\",\n      children: \"Comments\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Comments in GenExpr follow the C style syntax for both single-line and multi-line comments. Single-line comments start withand multi-line comments are defined by.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// this is a comment, below we sample an input \"\n        }), \"\\npix \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" sample( \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in1\"\n        }), \" , norm);\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"multiple-return-values\",\n      children: \"Multiple Return Values\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Just as object boxes can have multiple inlets and outlets, function in GenExpr can take multiple arguments and can return multiple values. The object \", _jsx(_components.a, {\n        href: \"/reference/gen_common_cartopol\",\n        title: \"gen_common_cartopol\",\n        children: \"cartopol\"\n      }), \" has two inlets and two outlets. Similarly, in GenExpr the \", _jsx(_components.a, {\n        href: \"/reference/gen_common_cartopol\",\n        title: \"gen_common_cartopol\",\n        children: \"cartopol\"\n      }), \" function takes two arguments and returns two values. In code, this looks like r, theta = cartopol(x, y). Functions that return mutiple values can assign to a list of variables. The syntax follows the pattern:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [\"var1, var2, var3, … \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"<\"\n        }), \"expression\", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \">\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"When a function returns multiple values but assigns to only one value, the unused return values are simply ignored. When a return value is ignored, the GenExpr compiler eliminates any unnecessary calculations. The function \", _jsx(_components.a, {\n        href: \"/reference/gen_common_cartopol\",\n        title: \"gen_common_cartopol\",\n        children: \"cartopol\"\n      }), \" could be expanded out to\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [\"r, theta \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" sqrt(x\", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"*\"\n        }), \"x\", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"+\"\n        }), \"y\", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"*\"\n        }), \"y), atan2(y, x)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If we remove theta and have instead\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [\"r \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" sqrt(x\", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"*\"\n        }), \"x\", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"+\"\n        }), \"y\", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"*\"\n        }), \"y), atan2(y, x)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"the compiler simplifies it to\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [\"r \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" sqrt(x\", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"*\"\n        }), \"x\", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"+\"\n        }), \"y\", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"*\"\n        }), \"y)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In the reverse case where we only use theta, the Gen compiler will strip out the calculations for r\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [\"notused, theta \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" sqrt(x\", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"*\"\n        }), \"x\", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"+\"\n        }), \"y\", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"*\"\n        }), \"y), atan2(y, x);\\n \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"out\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" theta;\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"effectively becomes\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [\"theta \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" atan2(y, x);\\n \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"out\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" theta;\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Even for more complex examples where the outputs share intermediate calculations, the compiler eliminates unnecessary operations, so there is no performance penalty for not using all of a function’s return values.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Just as the left-hand side list of variable names being assigned to are separated by commas, the right-hand side list of expressions can also be separated by commas:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [\"sum, diff \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in1\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"+\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in2\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in1\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"-\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in2\"\n        }), \" \\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"out1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"out2\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" diff, sum\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If there are more values on the left-hand side than on the right-hand side, the extra variable names are given a value of zero.\\nFor example,\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"out1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"out2\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in1\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"becomes\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"out1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"out2\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If any of the expressions in the right-hand side return more than one value, these additional values will be ignored unless the expression is the last item in the right-hand side list. This is complex to describe, but should be clear from these examples:\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Unused Return Values\"\n      }), \"\\nThe second return value gets discarded and cartopol is optimized:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [\"r \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" cartopol(x, y)\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Extra Assignment Values\"\n      }), \"\\nZeros are assigned to extra assignment values:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [\"x, y \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in1\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"becomes\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [\"x, y \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in1\"\n        }), \" ,  \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Multiple Return Values in an Expression List\"\n      }), \"\\nOnly the last expression can return multiple values. cartopol’s second return value discarded, as it is not the last expression in the right-hand side:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [\"r,  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"out1\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" cartopol(x, y),  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in1\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Here cartopol returns both values, since it is in the last position:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"out1\"\n        }), \" , r, theta \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in1\"\n        }), \" , cartopol(x, y)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The same principle applies when expressions are used as arguments to a function call. In this example, the two output values of poltocar connect to the two input values of min:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"out\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" min(poltocar( \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in1\"\n        }), \" ,  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in2\"\n        }), \" ))\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"defining-genexpr-functions\",\n      children: \"Defining GenExpr Functions\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Defining new functions in GenExpr happens in much the same way as other familiar programming languages. Since there are no types in GenExpr function arguments are specified simply with a name. A basic function definition with an equivalent patcher representation looks like the following. Note that functions must be declared \", _jsx(_components.strong, {\n        children: \"before\"\n      }), \" all statements:\"]\n    }), \"\\n\", _jsx(_components.p, {}), _jsxs(_components.figure, {\n      \"data-variant\": \"image\",\n      children: [\"\\n\", _jsx(_components.img, {\n        alt: \"\",\n        height: \"272\",\n        src: \"../../userguide/images/1b5b532d25b880b5d5722e8b31ff8441_768.webp\",\n        srcSet: \"../../userguide/images/1b5b532d25b880b5d5722e8b31ff8441_768.webp 2x\",\n        title: \"genexpr_006\",\n        width: \"384\"\n      }), \"\\n\\n\"]\n    }), _jsx(_components.p, {}), \"\\n\", _jsx(_components.p, {\n      children: \"A function returning multiple values looks like:\"\n    }), \"\\n\", _jsx(_components.p, {}), _jsxs(_components.figure, {\n      \"data-variant\": \"image\",\n      children: [\"\\n\", _jsx(_components.img, {\n        alt: \"\",\n        height: \"288\",\n        src: \"../../userguide/images/7333f2cad5ae933396c91bdf3fd664ad_1118.webp\",\n        srcSet: \"../../userguide/images/7333f2cad5ae933396c91bdf3fd664ad_1118.webp 2x\",\n        title: \"genexpr_007\",\n        width: \"559\"\n      }), \"\\n\\n\"]\n    }), _jsx(_components.p, {}), \"\\n\", _jsx(_components.p, {\n      children: \"The cylinder operator in Jitter Gen objects is defined as:\"\n    }), \"\\n\", _jsx(_components.p, {}), _jsxs(_components.figure, {\n      \"data-variant\": \"image\",\n      children: [\"\\n\", _jsx(_components.img, {\n        alt: \"\",\n        height: \"384\",\n        src: \"../../userguide/images/88b1f311c2d218811cf5ea45d3f15462_1380.webp\",\n        srcSet: \"../../userguide/images/88b1f311c2d218811cf5ea45d3f15462_1380.webp 2x\",\n        title: \"genexpr_008\",\n        width: \"690\"\n      }), \"\\n\\n\"]\n    }), _jsx(_components.p, {}), \"\\n\", _jsx(_components.p, {\n      children: \"While simple functions in GenExpr can be easily patched together, more involved functions like the above cylinder definition start to become unwieldy, especially if the function is used several times within the GenExpr code. This is the advantage of textual representations.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"operator-attributes\",\n      children: \"Operator Attributes\"\n    }), \"\\n\", _jsx(_components.p, {}), _jsxs(_components.figure, {\n      \"data-variant\": \"image\",\n      children: [\"\\n\", _jsx(_components.img, {\n        alt: \"\",\n        height: \"213\",\n        src: \"../../userguide/images/369362087511f592b38a7ba78c38c4e8_1274.webp\",\n        srcSet: \"../../userguide/images/369362087511f592b38a7ba78c38c4e8_1274.webp 2x\",\n        title: \"genexpr_009\",\n        width: \"637\"\n      }), \"\\n\\n\"]\n    }), _jsx(_components.p, {}), \"\\n\", _jsxs(_components.p, {\n      children: [\"In Gen patchers, some objects have attributes like the Jitter Gen operator \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_sample\",\n        title: \"gen_jit_sample\",\n        children: \"sample\"\n      }), \", which as a \", _jsx(_components.code, {\n        children: \"boundmode\"\n      }), \" attribute.  In GenExpr, function arguments correspond to operator inlets and function return values correspond to outlets.  Attributes are set using a key/value style argument.  For example:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"out\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" sample( \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" , norm, boundmode\", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"mirror\\\"\"\n        }), \" );\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"will use a version of the \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_sample\",\n        title: \"gen_jit_sample\",\n        children: \"sample\"\n      }), \" operator with a mirroring boundary behavior. The attribute is set with boundmode as the \", _jsx(_components.em, {\n        children: \"key\"\n      }), \" and \\\"mirror\\\" as its \", _jsx(_components.em, {\n        children: \"value\"\n      }), \". Since the concept of Max messages doesn't exist within Gen patchers, attributes for built-in operators are not dynamically modifiable. This holds equally in GenExpr. Such attribute values must be constants. If the attribute takes a numerical value, it cannot be assigned to from a variable.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"attributes-in-function-definitions\",\n      children: \"Attributes in Function Definitions\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Attributes can also be defined for function definitions.  Here, attributes can be dynamic, behaving in a similar manner to how \", _jsx(_components.a, {\n        href: \"/reference/gen_common_setparam\",\n        title: \"gen_common_setparam\",\n        children: \"setparam\"\n      }), \" interacts with subpatcher parameters.  Attributes can be defined in one of two ways.  With one syntax, the attribute is defined and given a default in the function signature.  With the other, a \", _jsx(_components.a, {\n        href: \"gen_common_param\",\n        title: \"gen_common_param\",\n        children: \"Param\"\n      }), \" object is declared in the function, adding the name of the parameter as an attribute to the function.\"]\n    }), \"\\n\", _jsx(_components.p, {}), _jsxs(_components.figure, {\n      \"data-variant\": \"image\",\n      children: [\"\\n\", _jsx(_components.img, {\n        alt: \"\",\n        height: \"390\",\n        src: \"../../userguide/images/c3cf34fe69444d257a2878cc7aa23f25_1508.webp\",\n        srcSet: \"../../userguide/images/c3cf34fe69444d257a2878cc7aa23f25_1508.webp 2x\",\n        title: \"genexpr_010\",\n        width: \"754\"\n      }), \"\\n\\n\"]\n    }), _jsx(_components.p, {}), \"\\n\", _jsxs(_components.p, {\n      children: [\"With the first method, only the default value of the attribute can be defined.  With the second method, other properties such as minimum and maximum values for the attribute can be set.  By declaring a \", _jsx(_components.a, {\n        href: \"/reference/gen_common_param\",\n        title: \"gen_common_param\",\n        children: \"param\"\n      }), \" object, you get more control over how the attribute operates.\"]\n    }), \"\\n\", _jsx(_components.p, {}), _jsxs(_components.figure, {\n      \"data-variant\": \"image\",\n      children: [\"\\n\", _jsx(_components.img, {\n        alt: \"\",\n        height: \"317\",\n        src: \"../../userguide/images/d9751451127aac2ab9e9119ac5402e2e_1736.webp\",\n        srcSet: \"../../userguide/images/d9751451127aac2ab9e9119ac5402e2e_1736.webp 2x\",\n        title: \"genexpr_011\",\n        width: \"868\"\n      }), \"\\n\\n\"]\n    }), _jsx(_components.p, {}), \"\\n\", _jsxs(_components.p, {\n      children: [\"As with built-in operators, attributes of function definitions can be set with key-value syntax.  In the above example, the \", _jsx(_components.code, {\n        children: \"amp\"\n      }), \" attribute is given a value of 0.5 while the \", _jsx(_components.code, {\n        children: \"offset\"\n      }), \" attribute is given a value of \", _jsx(_components.code, {\n        children: \"in1 * 2\"\n      }), \", which is an expression that is not constant but valid because \", _jsx(_components.code, {\n        children: \"func\"\n      }), \" is a function definition.  Note, however, that the \", _jsx(_components.code, {\n        children: \"offset\"\n      }), \" attribute has minimum and maximum values defined, so any expression assigned to it will be clamped to that range.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"abstractions-as-genexpr-functions\",\n      children: \"Abstractions as GenExpr Functions\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Structurally, GenExpr functions are equivalent to Gen patchers.  Both can have inputs, outputs and named parameters.  In GenExpr, Gen patchers save as abstractions (.gendsp or .genjit files) can be used as functions.  When the GenExpr interpreter encounters a function it can't find the definition of, it will use the current Max search paths to look for a Gen abstraction with the name of the function.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"out1\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" myAbstraction( \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in1\"\n        }), \" )\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"There is no definition of the function myAbstraction in the above code and it isn't a built-in operator, so Max will try to find a Gen abstraction with that name. The GenExpr interpreter will look for \", _jsx(_components.code, {\n        children: \"myAbstraction.gendsp\"\n      }), \" in the case of \", _jsx(_components.a, {\n        href: \"/reference/gen~\",\n        title: \"gen~\",\n        children: \"gen~\"\n      }), \" or \", _jsx(_components.code, {\n        children: \"myAbstraction.genjit\"\n      }), \" in the case of the Jitter Gen objects \", _jsx(_components.a, {\n        href: \"/reference/jit.gen\",\n        title: \"jit.gen\",\n        children: \"jit.gen\"\n      }), \", \", _jsx(_components.a, {\n        href: \"/reference/jit.pix\",\n        title: \"jit.pix\",\n        children: \"jit.pix\"\n      }), \", or \", _jsx(_components.a, {\n        href: \"/reference/jit.gl.pix\",\n        title: \"jit.gl.pix\",\n        children: \"jit.gl.pix\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"There are some caveats with using abstractions as GenExpr functions.  GenExpr function names must be valid identifiers.  An identifier in GenExpr is a sequence of characters starting with a letter or an underscore (\", _jsx(_components.code, {\n        children: \"[a-z]\"\n      }), \", \", _jsx(_components.code, {\n        children: \"[A-Z]\"\n      }), \", \", _jsx(_components.code, {\n        children: \"_\"\n      }), \") followed by any number of letters, numbers or underscores (\", _jsx(_components.code, {\n        children: \"[a-z]\"\n      }), \", \", _jsx(_components.code, {\n        children: \"[A-Z]\"\n      }), \", \", _jsx(_components.code, {\n        children: \"[0-9]\"\n      }), \", \", _jsx(_components.code, {\n        children: \"_\"\n      }), \").  It is not uncommon for Max subpatchers to have other chartacters such as \", _jsx(_components.code, {\n        children: \"~\"\n      }), \" or \", _jsx(_components.code, {\n        children: \".\"\n      }), \" in them.  These are invalid characters when it comes to GenExpr function names, so if they're used in the name of a Gen abstraction, they cannot be used as GenExpr functions.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"requiring-genexpr-files\",\n      children: \"Requiring GenExpr Files\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"When defining operators in GenExpr, it can be handy to keep them in a separate file so that they can be reused frequently without having to constantly re-type the operator definition in a codebox.  To include GenExpr operators defined in a separate file, use the \", _jsx(_components.code, {\n        children: \"require\"\n      }), \" operator.  The \", _jsx(_components.code, {\n        children: \"require\"\n      }), \" operator takes the name of a \", _jsx(_components.code, {\n        children: \".genexpr\"\n      }), \" file and loads its definitions.  The following are all valid ways to require a \", _jsx(_components.code, {\n        children: \".genexpr\"\n      }), \" file:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [\"require( \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"mylib\\\"\"\n        }), \" )\\nrequire( \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"mylib\\\"\"\n        }), \" );\\nrequire \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"mylib\\\"\"\n        }), \" \\nrequire \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"mylib\\\"\"\n        }), \" ;\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In the above code, calling \", _jsx(_components.code, {\n        children: \"require\"\n      }), \" triggers the codebox to look for the file 'mylib.genexpr' using the Max \", _jsx(_components.a, {\n        href: \"../search_path.md\",\n        children: \"search path\"\n      }), \".  Required \", _jsx(_components.code, {\n        children: \".genexpr\"\n      }), \" files can also require other files.  If a file is required more than once, it will only be loaded once.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"GenExpr files can be created and edited using the built-in Max text editor.  If a GenExpr file is required in a gen object and the file is edited and saved, the Gen object will detect that a file it depends on has changed through filewatching and recompile itself to reflect the new changes.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"branching-and-looping\",\n      children: \"Branching and Looping\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Branching and looping is supported in GenExpr with \", _jsx(_components.code, {\n        children: \"if/else\"\n      }), \", \", _jsx(_components.code, {\n        children: \"for\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"while\"\n      }), \" constructs. \", _jsx(_components.code, {\n        children: \"if\"\n      }), \" statements can be chained together using \", _jsx(_components.code, {\n        children: \"else if\"\n      }), \" an arbitrary number of times such that different blocks of code will be executed depending on different conditions.  For example:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \">\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.5\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"out\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" cos(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"*\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"pi\"\n        }), \");\\n}\\nelse \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \">\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.25\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"out\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" sin( \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"*\"\n        }), _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"pi\"\n        }), \");\\n}\\nelse {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"out\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" cos(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"*\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"pi\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"*\"\n        }), \" sin(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"*\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"pi\"\n        }), \");\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Note that in the Jitter gen objects, \", _jsx(_components.code, {\n        children: \"if\"\n      }), \" statements with vector-valued conditions will only use the first element of the vector to determine whether a block of code should be tested or not.\\n\", _jsx(_components.code, {\n        children: \"while\"\n      }), \" loops in GenExpr are similar to those in many other languages:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [\"i \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \";\\nval \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" (i \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"<\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \") {\\n  i \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"+\"\n        }), _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \";\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// accumulate \"\n        }), \"\\n  val \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"+\"\n        }), _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" i;\\n}\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"out\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" val;\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"for\"\n      }), \" loops are also similar to this in many other languages although there is no \", _jsx(_components.code, {\n        children: \"++\"\n      }), \" operator in GenExpr to increment a loop counter.  Instead, += can be used:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [\"val \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \" ;\\n for (i\", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"; i \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"<\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \"; i \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"+\"\n        }), _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \") {\\n   \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// accumulate \"\n        }), \"\\n  val \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"+\"\n        }), _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" i;\\n}\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"out\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" val;\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Since GenExpr is compiled on-the-fly, it can be easy to make a programming mistake and create an infinite loop.  All of the gen objects have protections against infinite loops, so while an infinite loop might slow things down, it won't cause Max to get stuck and freeze.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Also, note that in many cases values in GenExpr are floating point, even loop counters.  Floating point numbers can't exactly represent every number, sometimes a little fudge factor to account for this might be necessary.  For example, this loop:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [\"val \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \";\\nfor (i \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"; i \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"<=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"; i \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"+\"\n        }), _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.05\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// accumulate \"\n        }), \"\\n  val \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"+\"\n        }), _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" i;\\n}\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"out\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" val;\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"will likely not reach 1.0 despite the \", _jsx(_components.code, {\n        children: \"<=\"\n      }), \" operator because of floating point precision.  Instead, write something like:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [\"val \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \";\\nfor (i \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \" ; i \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"<=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1.04\"\n        }), \" ; i \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"+\"\n        }), _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.05\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// accumulate \"\n        }), \"\\n  val \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"+\"\n        }), _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" i;\\n}\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"out\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" val;\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"to ensure that the \", _jsx(_components.code, {\n        children: \"i\"\n      }), \" variable goes all the way to 1.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"continue-and-break\",\n      children: \"Continue and Break\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"With looping constructs, GenExpr supports \", _jsx(_components.code, {\n        children: \"break\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"continue\"\n      }), \" statements. \", _jsx(_components.code, {\n        children: \"break\"\n      }), \" causes an early exit from a loop while \", _jsx(_components.code, {\n        children: \"continue\"\n      }), \" causes the loop to start the next iteration without finishing the current one.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [\"val \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \";\\nfor (i \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \" ; i \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"<\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \"; i \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"+\"\n        }), _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (val \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \">\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"20\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// bail early \"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"break\"\n        }), \";\\n  }\\n  val \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"+\"\n        }), _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" i;\\n}\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"out\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" val;\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [\"val \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \" ;\\nfor (i \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \" ;i \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"<\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \"; i \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"+\"\n        }), _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (val \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"==\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// skip an iteration \"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"continue\"\n        }), \";\\n  }\\n  val \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"+\"\n        }), _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" i;\\n}\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"out\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" val;\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"genexpr-and-jitter-inputs\",\n      children: \"GenExpr and Jitter Inputs\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Jitter Gen objects take both Jitter matrices (\", _jsx(_components.a, {\n        href: \"/reference/jit.matrix\",\n        title: \"jit.matrix\",\n        children: \"jit.matrix\"\n      }), \") and/or textures (\", _jsx(_components.a, {\n        href: \"/reference/jit.gl.texture\",\n        title: \"jit.gl.texture\",\n        children: \"jit.gl.texture\"\n      }), \") depending on the object.  Within the Gen patcher the operator \", _jsx(_components.code, {\n        children: \"in\"\n      }), \" represents both the input matrix or texture in its entirety \", _jsx(_components.em, {\n        children: \"and\"\n      }), \" the current cell of that input being processed.  In most cases, the \", _jsx(_components.code, {\n        children: \"in\"\n      }), \" operator represents the current cell being processed.  The only time where it represents the entire input is with the \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_sample\",\n        title: \"gen_jit_sample\",\n        children: \"sample\"\n      }), \" and \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_nearest\",\n        title: \"gen_jit_nearest\",\n        children: \"nearest\"\n      }), \" operators.  Only an \", _jsx(_components.code, {\n        children: \"in\"\n      }), \" operator can be connected to the left input of \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_sample\",\n        title: \"gen_jit_sample\",\n        children: \"sample\"\n      }), \" and \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_nearest\",\n        title: \"gen_jit_nearest\",\n        children: \"nearest\"\n      }), \", which are used to grab data from arbitrary locations within the input.  The same holds true when \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_sample\",\n        title: \"gen_jit_sample\",\n        children: \"sample\"\n      }), \" and \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_nearest\",\n        title: \"gen_jit_nearest\",\n        children: \"nearest\"\n      }), \" are used in GenExpr.\"]\n    }), \"\\n\", _jsx(_components.p, {}), _jsxs(_components.figure, {\n      \"data-variant\": \"image\",\n      children: [\"\\n\", _jsx(_components.img, {\n        alt: \"\",\n        height: \"420\",\n        src: \"../../userguide/images/8aee3e87d66a0bc2222b12d256285536_836.webp\",\n        srcSet: \"../../userguide/images/8aee3e87d66a0bc2222b12d256285536_836.webp 2x\",\n        title: \"genexpr_012\",\n        width: \"418\"\n      }), \"\\n\\n\"]\n    }), _jsx(_components.p, {}), \"\\n\", _jsxs(_components.p, {\n      children: [\"When GenExpr code is compiled, the inputs to \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_sample\",\n        title: \"gen_jit_sample\",\n        children: \"sample\"\n      }), \" and \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_nearest\",\n        title: \"gen_jit_nearest\",\n        children: \"nearest\"\n      }), \" are validated to ensure that their first arguments are actually Gen patcher inputs and an error thrown if this isn't the case.  The validation process can track inputs even through function calls so \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_sample\",\n        title: \"gen_jit_sample\",\n        children: \"sample\"\n      }), \" and \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_nearest\",\n        title: \"gen_jit_nearest\",\n        children: \"nearest\"\n      }), \" can be used within functions without issue.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"genexpr-and-jitter-coordinate-operations\",\n      children: \"GenExpr and Jitter Coordinate Operations\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The coordinate operations in Jitter Gen patchers (\", _jsx(_components.a, {\n        href: \"/reference/gen_jit_norm\",\n        title: \"gen_jit_norm\",\n        children: \"norm\"\n      }), \", \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_snorm\",\n        title: \"gen_jit_snorm\",\n        children: \"snorm\"\n      }), \", \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_cell\",\n        title: \"gen_jit_cell\",\n        children: \"cell\"\n      }), \", and \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_dim\",\n        title: \"gen_jit_dim\",\n        children: \"dim\"\n      }), \") are special-case operators that are a hybrid betwen operator and global variable.  There are two equally valid syntaxes for using these operators:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-genexpr\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"out1\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" norm \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"*\"\n        }), \" dim();\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In the first instance above, \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_norm\",\n        title: \"gen_jit_norm\",\n        children: \"norm\"\n      }), \" is syntactically a global variable while \", _jsx(_components.a, {\n        href: \"/reference/gen_jit_dim\",\n        title: \"gen_jit_dim\",\n        children: \"dim\"\n      }), \" is syntactically a function call.  All of the coordinate operators follow this convention.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"technical-notes\",\n      children: \"Technical Notes\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"GenExpr is a type-less language. Variables are given types automatically by the compiler depending on the Gen domain and the Gen object’s inputs. Gen variables are also local-to-scope by default so they don’t have to be declared with a keyword like var as in JavaScript. Note that GenExpr has no array notation \", _jsx(_components.code, {\n        children: \"[index]\"\n      }), \"  as there is currently no notion of an array structure.\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","tags":[],"kind":"","contributors":[],"publishDate":"2024-10-30T12:00:00.000Z","categories":[],"files":[],"articles":[]}